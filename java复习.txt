https://www.bilibili.com/video/BV1Ha4y1v7hE?p=274

https://www.bilibili.com/video/BV1hE411o7w7?p=41  Spring注解

https://www.bilibili.com/video/BV1Bg4y1q7q2?p=5  Spring mvc 

https://www.bilibili.com/video/av66600360/?p=13	   ES 

https://www.bilibili.com/video/BV1dJ411N7Um?p=16   tomcat


sychornized  修饰在方法块时 追溯的是对象  ，   如果是静态，追溯的是类




CMS收集器   https://www.cnblogs.com/cxxjohnson/p/8625713.html


Zookeeper = 文件系统 + 监听通知机制


Hive 与 Hbase 的区别https://www.jianshu.com/p/a540fb879dd3


	Hive适合用来对一段时间内的数据进行分析查询，例如，用来计算趋势或者网站的日志。Hive不应该用来进行实时的查询。因为它需要很长时间才可以返回结果。
    Hbase非常适合用来进行大数据的实时查询。Facebook用Hbase进行消息和实时的分析。它也可以用来统计Facebook的连接数。


	hive 是 给开发人员提供 sql  来操作 hdfs的 工具   Hive目前还不支持事务；不能对表数据进行修改

	Hive定义了一种类似SQL的查询语言，被称为HQL，对于熟悉SQL的用户可以直接利用Hive来查询数据。同时，这个语言也允许熟悉 MapReduce 开发者们开发自定义的mappers和reducers来处理内建的mappers和reducers无法完成的复杂的分析工作。Hive可以允许用户编写自己定义的函数UDF，来在查询中使用。Hive中有3种UDF：User Defined Functions（UDF）、User Defined Aggregation Functions（UDAF）、User Defined Table Generating Functions（UDTF）。
	今天，Hive已经是一个成功的Apache项目，很多组织把它用作一个通用的、可伸缩的数据处理平台。
	　　当然，Hive和传统的关系型数据库有很大的区别，Hive将外部的任务解析成一个MapReduce可执行计划，而启动MapReduce是一个高延迟的一件事，每次提交任务和执行任务都需要消耗很多时间，这也就决定Hive只能处理一些高延迟的应用（如果你想处理低延迟的应用，你可以去考虑一下Hbase）。同时，由于设计的目标不一样，Hive目前还不支持事务；不能对表数据进行修改（不能更新、删除、插入；只能通过文件追加数据、重新导入数据）；不能对列建立索引（但是Hive支持索引的建立，但是不能提高Hive的查询速度。如果你想提高Hive的查询速度，请学习Hive的分区、桶的应用）。

	Hbase： Hadoop database 的简称，也就是基于Hadoop数据库，是一种NoSQL数据库，主要适用于海量明细数据（十亿、百亿）的随机实时查询，如日志明细、交易清单、轨迹行为等。
	Hive：Hive是Hadoop数据仓库，严格来说，不是数据库，主要是让开发人员能够通过SQL来计算和处理HDFS上的结构化数据，适用于离线的批量数据计算。

	通过元数据来描述Hdfs上的结构化文本数据，通俗点来说，就是定义一张表来描述HDFS上的结构化文本，包括各列数据名称，数据类型是什么等，方便我们处理数据，当前很多SQL ON Hadoop的计算引擎均用的是hive的元数据，如Spark SQL、Impala等；基于第一点，通过SQL来处理和计算HDFS的数据，Hive会将SQL翻译为Mapreduce来处理数据；



 并发标记清理（Concurrent Mark Sweep，CMS）收集器也称为并发低停顿收集器（Concurrent Low Pause Collector）或低延迟（low-latency）垃圾收集器；
				针对老年代；

					  基于"标记-清除"算法(不进行压缩操作，产生内存碎片)；            

					  以获取最短回收停顿时间为目标；

					  并发收集、低停顿；

					  需要更多的内存（看后面的缺点）；

						

					  是HotSpot在JDK1.5推出的第一款真正意义上的并发（Concurrent）收集器；

					  第一次实现了让垃圾收集线程与用户线程（基本上）同时工作；
				  
				与用户交互较多的场景；        

					  希望系统停顿时间最短，注重服务的响应速度；

					  以给用户带来较好的体验；

					  如常见WEB、B/S系统的服务器上的应用；


代理模式：操作对象由 接口的实现对象变为代理对象方法；
		静态代理：构造方法 传入代理的实现对象；用代理对象使用接口方法时，需要挨个写入对应方法；
		动态代理：构造方法传入Object , 利用Proxy.newProxyInstance()工具方法 返回动态代理对象，使用时 用此对象直接调用接口的方法即可；再也不用修改代理了。
					//将实现类交给动态代理
					Idao proxy = (Idao) new NewProxyFactory(idaoImpl).getProxyInstance();
					//动态代理实现方法
					proxy.save();
					proxy.delete();
工厂模式：new对象的操作 包装至工厂，不用自己来新生成对象；

单例模式： 私有化类的构造方法，提供获取类对象的方法  getInstance(); 返回唯一new的对象

待学习知识点：代理  动态代理        垃圾回收器   jvm

父类静态代码块
子类静态代码块
父类构造代码块                     西安所有的静态  ——>父 {}  (){}    ——>子{}  (){} 
父类构造方法
子类构造代码块
子类构造方法


jvm 垃圾回收器 https://www.cnblogs.com/bailiyi/p/12013756.html
				https://www.cnblogs.com/leeego-123/p/11298267.html
		 引用计数法
		 可达性分析   GC Roots  计算引用链
			HotSpot
				在HotSpot中，虚拟机把对象内的什么偏移量上是什么类型的数据的信息存在到一个叫做“OopMap”的数据结构中。
				这样在计算引用链时直接查OopMap即可，不用到整个内存中去挨个找了，由此提高了分析速度。
				  安全点   安全区域
		
		至少要经过两次标记。  
		 
			标记-清除算法
			复制算法
			标记-整理算法
			分代回收算法
			
		并行和并发：相对于用户线程而言
		
		
		年轻代：eden区  s1  s2     老年代:            永久代/元空间：方法区（一般不做gc）
		
			年轻代使用复制算法（minor GC）， eden满  执行一次复制算法 至 s1；  eden再满 ，用s1一起再做一次复制算法  至 s2 ；
					每一次minorGC对象年龄+1岁；默认15岁时，就会进入老年代  
					
			老年代使用标记整理算法，gc后将幸存的内存碎片整合
				CMS  Concurrent Mark Sweep 
					是一款十分优秀的老年代垃圾收集器，响应速度快、停顿时间短，是现在大多数互联网公司的选择，大家要好好掌握：
					初始标记（STW）		 标记GC Roots能关联到的对象（即有引用的对象）
					并发标记             是执行GC Roots查找引用的过程，不需要用户线程停顿
					重新标记（STW）
					并发清除
		

jvm  堆：new出来的对象 存放在内存中，指针指向方法区
	 方法区：类模板 永久带
	 栈：
     程序计数器
	 



NIO   https://blog.csdn.net/u011381576/article/details/79876754

一、使用NIO完成网络通信的三个核心：
	
	1 通道（Channal）：负责连接
		SocketChallel 
		ServerSocketChallel 
		DatagramChannel
		
		Pipe.SinkChannel
		Pipe.sourceChannel
		
	2 缓冲区（Buffer）：负责数据的存储
	3 选择器（Selector）：是SelectableChannel 的多路复用器。用于监控SelectableChannel的IO状况

	
	NIO和传统IO（一下简称IO）之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的
	
	IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变得可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。
	
	Selector运行单线程处理多个Channel，如果你的应用打开了多个通道，但每个连接的流量都很低，使用Selector就会很方便。例如在一个聊天服务器中。要使用Selector, 得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新的连接进来、数据接收等。
	
	
	
		
	  客户端 发送图片并接收反馈
	  
			//获取通道
			SocketChannel sChannel = SocketChannel.open(new InetSocketAddress("127.0.0.1",9898))
			
		************************************非阻塞，客户端发送消息***********************************************************************
			//切换到非阻塞模式
			sChannel.configureBlocking(false);
			
			//发送消息给服务端
			ByteBuffer buf = ByteBuffer.allocate(1024);
			buf.put("你好，我是非阻塞模式发来的消息".getBytes());
			buf.flip();
			sChannel.write(buf);
			buf.clear();
			
			//关闭通道
			sChannel.close();
			
			
		**********************************************************************************************************************************
			
			FileChannel inChannel = FileChannel.open(Path.get("1.jpg"), StandardOpenOption.READ)
			
			//分配指定大小的缓冲区
			ByteBuffer buf = ByteBuffer.allocate(1024);
			
			//读取本地文件，并发送到服务器
			while(inChannel.read(buf) != -1){
				buf.flip();//打开读取操作状态
				sChannel.write(buf);
				buf.clear();//清空缓冲区
			}
			
			//sChannel.shutdownOutput();切断管道
			
			//接收服务端 讯息
			int len = 0;
			while((len = sChannel.read(buf)) != -1){
				buf.flip();
				System.out.println(new  String(buf.array(),0,len);
				buf.clear();
			}
			
			//关闭通道
			inChannel.close();
			sChannel.close();
			
			
	 服务端 接收
	 
			//获取通道
			ServerSocketChannel SSChannel = ServerSocketChannel.open();
			
			FileChannel outChannel = FileChannel.open(Paths.get("2.jpg"),StandardOpenOption.WRITE,StandardOpenOption.CREATE);
			
			//绑定连接
			ssChannel.bind(new InetSocketAddress(9898));
		**********************************************************************************************************************************************************	
			//切换非阻塞模式
			ssChannel.configureBlocking(false);
			
			//获取选择器
			Selector selector = Selector.open();
			
			//将通道注册到选择器上，并且制定“监听‘接收’事件“
			ssChannel.regiest(selector,SelectionKet.OP_ACCEPT);//此处为 接收 事件
			
			//轮询式得接收选择器上已经“准备就绪”的事件
			while(selector.select() > 0){
				//获取当前选择器中所有注册的“选择键（已经就绪的监听事件）”
				Iterator<SelectionKey> it = selector.selectedKeys().iterator();
				
				while(it.hasNext){
					//获取准备“就绪”的事件
					SelectionKey sk = it.next();
					//判断就绪的事件
					if(sk.isAcceptable()){
						//若“接收就绪”，获取客户端连接
						SocketChallel sChannel = ssChannel.accept();
						//~~~~~~~~~~~~切换到非阻塞模式~~~~~~~~~
						sChannel.configureBlocking(false);
						//将该通道注册到选择器上
						sChannel.register(selector, SelectionKey.OP_READ);
					}else if(sk.isReadable()){
						//当获取当前选择器上“读就绪”状态的通道
						SocketChannel sChannel = (SocketChannel) sk.channel();//其实就是上一步刚注册的channel通道
						
						//读取数据
						ByteBuffer buf = ByteBuffer.allocate(1024);
						int len = 0;
						while((len = sChannel.read(buf)) != -1){
							buf.flip();
							System.out.println(new  String(buf.array(),0,len);
							buf.clear();
						}
					}
					
					//取消选择键electionKey  删除该次事件
					it.remove();
				}
			}
			
		**********************************************************************************************************************************************************	
			//获取客户端连接通道
			SocketChannel sChannel = ssChannel.accept();
			
			//分配指定大小的缓冲区
			ByteBuffer buf = ByteBuffer.allocate(1024);
			
			//读取本地文件，并发送到服务器
			while(sChannel.read(buf) != -1){
				buf.flip();//打开读取操作状态
				outChannel.write(buf);
				buf.clear();//清空缓冲区
			}
			
			//发送讯息
			buf.put("文件接收成功".getBytes());
			buf.flip();
			ssChannel.write(buf);
			
			
			//关闭通道
			sChannel.close();
			ssChannel.close();
			outChannel.close();
			



InnoDb   聚集索引   本升级就是以B+Tree 的索引组织   数据   而 构成的表      所以他一定会有主键（作为索引）

String::new


框架
   AOP面向切面  核心 是 动态代理机制
   
   JDK和CGLib动态代理实现和区别 https://zhuanlan.zhihu.com/p/106336169
   JDK动态代理的话，他有一个限制，就是它只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，如何创建动态代理实例哪？答案就是CGLib。
   
   JDK动态代理是面向接口的代理模式，如果被代理目标没有接口那么Spring也无能为力，Spring通过Java的反射机制生产被代理接口的新的匿名实现类，重写了其中AOP的增强方法。
   CGLib利用ASM开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。 	
	
   也就是说  要用JDK 就必须定义代理对象实现接口    而   CGLib 则不需要，但其必须可以被继承（不能用final修饰）
		CGLib 为子类（实现独有的方法）
	










static  静态  理解为 上浮标记修饰对象 与 本层次同级水平   （上浮 公用 ）
快捷操作 sout    启动main alt shift f10    重命名重构 shift+f6

gcDouble.compare(1.11, 12.1);返回int;

comoparTo  本类  大于 对比   升序 正

//有参构造器 书写
class Threada extends Thread{
	private CountDownLatch c;
	punlic Thread(CountDownLatch c){
		this.c = c;
	}
}


	匿名内部类：我的理解是对于要实现接口的对象，正常情况是新建类->实现接口->重写方法->产生对象（多态调用 new 新建的类）->调用重写的方法|||||||
				
				如果我们在代码中 只是临时使用接口重写的方法对象，以上步骤中，生成的 类只是临时的作用，重点在于重写的方法内容，此时就可以
				使用匿名内部类来 弱化这个类 从而简化代码
				
		类 类名 = new 接口名（）{
			@Override
            public void 重写的方法名() {
			}
		}		
		
	例如：
		new Thread(new Runnable() {
            @Override
            public void run() {
                while (true){
                    System.out.println("这是"+Thread.currentThread()+"线程");
                }

            }
        },"我的线程").start();

	如果接口是	函数式接口：接口中只有一个抽象方法的接口；注解未 @FunctionalInterface
		使用lambda表达式 简化为 
			new Thread(()-> System.out.println("这是"+Thread.currentThread()+"线程")).start();
			Collections.sort(lists, (o1,o2)->  o1.getAge()-o2.getAge());


面向对象的特点：
封装 继承 多态






1 1  11  111  1111

  
	
	
	
抽象： 约束你一定要做的事情；  模板模式 ， 模板中的事情规定到抽象方法中；
抽象类 继承抽象类 可以重写抽象方法，如果未全部重写 该类也必须定义为抽象类，供继承并最终重写（所以抽象类必须被继承，不被继承就没有意义，抽象类算是个父类）； 
接口 interface ：1.8 之前 只含有抽象方法 abstract  和 常量 public static final    1.8之后  可定义final 写入固定方法;接口是供类实现的 --> implement , 一个类 可实现多个接口；
			一个接口也可以继承多个接口： 很简单 预先规定的东西  不冲突 就可以 扩展 并戴帽子 给类 让类继承

抽象类有构造方法但不能创建对象 应为其中有未完成的抽象方法（反向思维，如果可创建对象，该未完成的抽象方法，如何表达）

1.8 之后的接口： 
	1 默认方法 default void run(){} 
	2 静态方法  供接口名直接调用 static void run(){} 
	3 私有方法  供接口内部自己调用（可以增加接口代码的简洁性）  1.9版本
	
final 固定          常量：只可被修改一次          

//恶汉表示很饿 来的时候你已经做好了，懒汉表示 偷懒 ，你用的时候我发现没有我再做
		//恶汉
		class SingleInstance{
			private SingleInstance instance;
			private SingleInstance(){
			}
			
			public SingleInstance getInstance(){
				if(null == instance){
					instance = new SingleInstance();
				}
				return this.instance;
			}
		}



    // 单例模式 特点：将构造方法私有化（即不暴露构造方法 不能new），静态生成 new对象 用以存储对象
		//恶汉
		class SingleInstance{
			public static SingleInstance instance = new SingleInstance();
			private SingleInstance(){
			}
			punlic static getInstance(){
				return instance;
			}
		}
		
    // 并且 静态地 暴露获得该唯一对象的方法， 获取是可通过类名直接获取

    //而枚举相当于多例模式  punlic enum Sex{
								boy, girl;
							}
							可用于 switch ：方便优雅
							
框架  API

  多态 
	同一个类型对象执行同一行为在不同状态下表现不同；
	
	
	
	
	父类类型 对象名称 = new 子类构造器    对象指向子类对象
	
	Animal animal1 = new Cat();
	Animal animal2 = new Dog();
	animal1.run();  //喵喵叫   
	animal2.run(); //汪汪叫
	
	对于方法的调用（行为） run() ： 编译看左 运行看右
	对于变量的获取（名称） name() ； 编译看左 运行看左         多态只认为行为向下看子类；
	
  多态的优点   
	Animal animal = new Cat();      可修改为  new Dog();  方便解耦    在觉得Cat不好用的时候   修改构造对象 Dog 左边无需修改
									父类类型  作为方法形参，其子类 都可作为入参传入方法: go(cat)
									public static void go(Animal animal){
									}
  多态的劣势：    
	 编译看左，不能直接调用子类独有的功能
	 
	 若要调用，需向下强转(classPassException  向下强转 写错 会引起转换方向报错)   Cat c = (Cat)animal;
	 所以一般在强转前 需要对其进行校验：
		if(animal instanceof Cat){}
	
	
 内部类  
	1 静态内部类：static 修饰的内部类  与普通类相同 (平级-->  内部 + 上浮 = 平级)
	2 实例内部类(成员内部类)：普通的内部类 ，该类内部的成员变量  例：private String name 不可用static 修饰， Outer.Inner
	    理解  类调用几次该内部类后 ，如果有static修饰该类的成员变量，该静态成员变量会上浮多次，从而与静态对象只存在一个的属性矛盾。    new Outter().new Inner()
	3 局部内部类：定义在代码块中的内部类{ punlic class A{}  }   不能为静态
	4 匿名内部类：属于局部内部类（最重要）   一个内部类，也是一个对象      场景：是被动 需要写成匿名内部类的 而非自己主动
	
		对于Animal抽象出来 run方法 我们想搞一个新的run()方法内容，又不想再创建一个新的继承了Animal的类
		此时 可以创建一个匿名内部类：
		Adnimal a = new Animal(){
			@Override
			punlic void run(){
				System.out.println("重新写的方法")
			}
		}
		a.run();
		
		场景：开发场景中需要 某些实现特定接口或者抽象方法的临时类时
			  （对于接口 interface 重写实现的方法 ）可以： 
		new 接口名（）{
			@override
			punlic void run(){
				System.out.println("重新写的方法")
			}
		}
		
		总而言之，通过回调 ，类只是临时的作用，重点在于重写的方法内容，此时  就需要匿名内部类来 弱化这个类 从而简化代码；
		最终的优化格式 （了解）：  btn.addActionListener( s -> Sysrem.out.println("用户点击了触发登陆"))
		
		
包：
	protected  允许其他包对他的子类访问，即继承他的类  在其他包中的访问权限；
	
	
API
	Object   
		toString()   
				-默认返回 对象在堆内存中的地址 格式：类的权限名@内存地址  com.biz.aghoo.Student@16B98e56
				-直接输出对象名称 默认调用toString()方法 
				-开发中输出对象地址毫无意义，更希望看到内容数据，所以 ===>  toString()方法需要我们重写，从而给定义我们想要的内容，一般可用工具自动生成
		equals()
				- 默认的 equals()方法 即为 ==    ； 比较对象内存地址
				- 重写equals()方法用来提供自定义判断相等的方法，一般可用工具自动生成       


	包装类  ：  面向对象的思想；对基本数据类型进行封装   特点：自动装箱、自动拆箱（混用） 但包装类 可以赋值为null;
				手工装箱：  Integer it = Integer.valueOf(12);
				手工拆箱：  Integer it3 = 111;
							int it33 = it3.intValue();
			优点：1 装箱后extend Object  调用 toString()方法获得对应字符串 
				  2 相反  把字符类型的数值 转换为对应类型  Integer.parseInt("21") Double.parseDouble("21") 不常用    常用====>
									int a =	Integer.valueOf("12");
									double d = Double.valueOf("12.14");
					 
					 
					
泛型：
	约束标签
	ArrayList<String> list = new ArrayList<>();  约束了其中只能装入 String  如果没约束的话 任何类型都可放入该 list (泛型不支持基本数据类型 int 等，需用Integer)
			但是，反射可以打破这种限制，因为反射作用在运行期，运行期不收泛型约束，我们就可以通过反射在此<String> 约束里放入 int 等其他内容;
	
	 泛型类：使用泛型定义的类 为泛型类  建议用 E T K V 作泛型类参数
		class myArrayList<E>{
			public void add(E e){
			}
			public void remove(E e){
			}
		}
	泛型方法：
		punlic <T> String arrToString(T[] nums){
			//只表逻辑
			T ele = nums[i];
			String str=ele
		}
	泛型接口  :  核心思想：在实现接口的时候传入真实的数据类型，这样重写的方法就是对该数据类型进行操作
			  public interface Date<E>{
				  void add(E e);
				  void delete(E e);
				  void update(E e);
			  }
			  
			  public class StudentData implements Data<Student>{
				@Override
				punlic void add(Student stu){
					
				}
				
				@Override
				punlic void delete(Student stu){
					
				}
				@Override
				punlic void update(Student stu){
					
				}
			  }
	泛型使用：虽然BMW和BENZ都继承了Car , 但是ArrayList<BMW>和ArrayList<BENZ>与ArrayList<Car>没有关系！泛型没有继承关系!
			 此时出现了通配符：？    
					可以用在《使用》泛型是代表一切类型
					E,T,K,V 在 《定义》泛型的时候代表一切类型
	泛型的上下限：使用了？后发现其占用位又可以代表了一起，绕了一圈又回来了 ， 那么如何限定泛型取值的范围呢？
			  ？extend Car:那么？必须是Car或者其子类（泛型的上限）
			  ？super Car：那么？必须是Car或者其父类（泛型的下限，不常见）
			  
		punlic void run(ArrayList<? extends Car> cars){}
		
		



			
			
			
		
			
数据结构：指数据以什么方式组织在一起。
		不同的数据结构 增删查的性能是不一样的
		不同的集合底层采用不同的数据结构。
		
		常见数据结构：栈  队列 数组 链表 红黑树
				1 队列：  先进先出 后进后出
				
				2 栈：后进先出，先进后出  （手枪弹夹）  |_|
				
				3 数组（内存中连续存储区域）  有索引（因为连续可很快计算其他元素地址）  查询快（索引 连续储存的内存） 增删慢（迁移）     |0|1|2|3|4|5|  
				
				4 链表（内存中不连续，每个元素都记录下个元素地址）  有索引（因为不连续不能较快速地计算其他元素地址）  查询慢（内存储存不连续）   
					增删快（直接摘除元素，对接相邻元素其他元素无需操作，首位操作更佳）
				     |0储存下个元素地址|-->|1|--> |2|--> |3|--> |4|
			    5 二叉树
					二叉排序（查找）树 小往左边走
						瘸子树
					
					
						->平衡二叉树（减小树高）增删改查性能都佳 
							左右差值不能超过1  
							右边失衡往左旋 左边失衡往右旋 
							旋转后仍然失衡 仍让失衡（如果左失衡仍往左旋转）旋转 再平衡旋转（再往右旋转）
							
							左左 往左摆  左树过高（多1的为此模块的左树）右旋即可
							左右 往左摆  右树过高（多1的为此模块的右树） 先左旋（其实是模块左旋）形成左左再右旋平衡
							右左 同理
							右右 同理
							
							实际先将ab旋转成aa再平衡旋转即可
							
				 红黑树 ： 就是平衡的二叉排序树  ，简答得说 是通过算法 保持旋转   平衡   保持高度最矮，从而使得红黑树为查找性能最好的树


集合   Collection 
		 Set  不重复                  List 可重复
		HashSet  TreeSet 有序（默认升序）      ArrayList  LinkedList
		LinkedHashSet
		
		Collection 集合没有索引 不能用  for(int i=0;i++;i<xx){}这种形式的遍历，以为Collection集合没有索引；
		遍历：
			增强for   for(String str: Lists){System.out.println(str}
			迭代器while(it.hasNext()){it.next()}
			JDK1.8 的遍历方式 lamda  lists.forEach(s -> System.out.println(s))							
	
	List 集合 一般使用ArrayList 有序 可重复 有索引	
		
		ArrayList
   
		List<String> lists = new ArrayList<>();  //使用多态，因为使用的基本都为Lists接口的方法
			有索引，增加了对于索引位置的操作
			lists.add(1,"mySQL"); 增 
			lists.remove(1,"mySQL"); 删
			lists.set(1,"yourSQL") 改
			
			遍历在Collect基础上 因为有索引 另外可以用 for循环，
				for(int i=0;i<lists.size();i++){}
	  
		LinkedList 底层游离元素以链表关联 双链表  增删较快（尤其首位） 查询慢
			适合 队列 和 栈 操作（首位较快）
			LinkedList<String> linkedLists = new LinkedList<String>(); //不使用多态，不然就无法要使用Linked独有的方法
			linkedLists.addFirst("mySql"); 添加至第一个；
			linkedLists.addLast("mySql"); 添加至最后一个；
			
			linkedLists.getFirst();查询第一个；
			linkedLists.removeFirst();移除第一个（返回该值）；
			
			栈：后进先出，先进后出：
			 linkedLists.push("第1个子弹")； 内核中的方法其实就是调用的addFirst();
			 linkedLists.push("第2个子弹")；
			 linkedLists.push("第3个子弹")；
			 linkedLists.push("第4个子弹")；
			 
			 linkedLists.pop(); 第4个子弹   内核中的方法其实就是调用removeFirst();
			 linkedLists.pop(); 第3个子弹
	
		综上：查询多增删少     用ArrayList  
			查询少首位增删多 用LinkedList 
  
	Set 无序，不重复，无索引
		Set<String> sets = new HashSet<>(); //经典代码
	
	1底层如何去重？
		1比较hashCode（内存地址） 如果不同则返回不同
		2如果相同 再比较equals方法
		所以：hashCode && equals 为真才相同
			所以如果想认为相同值的两个对象为重复的话，除了需重写equals方法外，还需重写hashCode()方法
	
	2无序的原因？
		根本原因是底层使用了hash表存储元素
		JDK1.8之前： 哈希表 = 数组 + 链表 + （哈希算法）    底层数组长度认为是6 
		JDK1.8之后： 哈希表 = 数组 + 链表 + 红黑树 + （哈希算法）
				当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少查询时间
	
  LinkedHashSet  有序不重复无索引 底层依然是哈希表存储，只是每个元素都额外带一个链（指针）来维护添加顺序
			不光增删查快，还有序。缺点是多了一个存储顺序的链会占用内存空间！！而且不允许重复，无索引
			
  TreeSet : 不重复 无索引 按照大小默认升序排序！
			1 有值特性的元素直接升序排序（浮点型，整形）
			2 字符串类型元素会按照首字符的编号排序
			3 对于自定义的引用数据类型，TreeSet默认无法排序，执行的时候回报错，因为人家不知道排序规则，懵逼了。所以需要定制排序规则：
				自定义的引用数据类型排序实现：方案 （如果两者都存在，优先2方案，即集合自带比较器）
				
				  1）直接为对象的类实现比较规则接口comparable 重写conpareTo方法：
						@Override
						punlic int compareTo(Employee o){
							//规则：java规则，如果程序员认为比较者(this)大于被比较者 返回正数；
											  如果程序员认为比较者(this)小于被比较者 返回负数；
											  如果程序员认为比较者(this)等于被比较者 返回0；
							return this.age - o.age;				  
						}
				  2) 为集合(创建后)设置比较器 Comparator对象 重写compare方法
						Set<Employee> employees = new TreeSet<>(new Comparator<Employee>(){
							@Override
							public int compare(Employee o1, Employee o2){
								retrun	o1.getAge()-o2.getAge();
							}
						});

 Collections 工具类；
    addAll：批量添加元素
		Collection<String> names = new ArrayList<>();
		Collections.addAll(names,"曹操","贾乃亮","王宝强","陈羽凡")
	shuffle:打乱有序集合
	sort:升序排序，与TreeSet相同 ，有值特性的元素直接升序排序，
		如果为自定义类对象：
		直接为对象的类实现比较规则接口comparable 重写conpareTo方法
		
		或者
		
		为集合(创建后)设置比较器 Comparator对象
		COllections.sort(oranges, new Comparator<Orange>(){
			@Override
			public int compare(Employee o1, Employee o2){
				retrun	o1.getAge()-o2.getAge();
			}
		})
  

  可变参数：在方法类中本身就是一个数组  
		sum();
        sum(1);
        sum(1,2);
        sum(1,2,3);
        sum(new int[]{1,2,3,4});
	
		public static void sum(int...nums){
			System.out.println(nums.length);
			System.out.println(Arrays.toString(nums));
			System.out.println("~~~~~~~~~~~~~~~~~~~~~~~~");
		}

Map集合  键值对
	 Map<K,V> 接口
	 
	 TreeMap<K,V>   HashMap<K,V>                                                                HashSet底层基于HashMap     （键不带值 机制类推）
					LinkedHashMap<K,V>  LinkedHashSet底层基于 LinkedHashMap   （键不带值 机制类推
	 Map集合的特点：
		1 Map集合的特点都是由建决定的；
		2 Map集合的建是无序不重复的，无索引；
			Map集合后面重复的键值对元素会覆盖前面的整个元素；
		3 Map集合的值无要求；
		4 Map集合的键值对都可以为null;
	 HashMap:      元素按照键是无序，不重复，无索引，值不做要求。
	 LinkedHashMap:元素按照键是有序，不重复，无索引，值不做要求
	 
   Map<String,Integer> maps = new HashMap<>();
     
	 
	 遍历  
		1) 通过 遍历key 遍历value
		2)  获得Map的内部类 Map.Entry<K, V> 作为for循环的 元素载体 遍历
			Map<String,Integer> maps = new HashMap<>();
			maps.put("小米", 133);
			maps.put("华为", 100);
			maps.put("锤子", 500);
			maps.put("vivo", 400);

			Set<Map.Entry<String, Integer>> entrySet = maps.entrySet();
			for (Map.Entry<String, Integer> elem : entrySet) {
				System.out.println(elem.getKey());
				System.out.println(elem.getValue());
				System.out.println("~~~~~~~~~~~~");
			}
		3) Lamda 表达式
			maps.forEach((k,v)->{
				System.out.println(k+"=>"+v);
				System.out.println("~~~~~~~~~~~~");
			});
		
	TreeMap: TreeSet底层基于TreeMap
	
 冒泡 
   for(int i=0;i<str.length()-1;i++{
	for(int j=0;j<str.length()-i-1;j++{
		if(str[j]>str[j+1]{
			String a = str[j];
			str[j]=str[j+1];
			str[j+1]=a;
		}
	}
   }
   
异常：
	try{
	
	}catch(Exception e){
		e.printStackTrace();
	}
	
	运行时异常 也通过try catch  捕获 ， 因为其会自动抛出异常
	做好将底层错误抛出至业务层面代码统一 try catch 处理：如此 在业务层理上可以在上下级判断该出是否有问题而做出对应的不同操作，从而使代码更安全。
		

	finally{
		一定会执行，一般用来关闭资源
		即便之前有return,也会执行
	}

 自定义编译期异常 会产生强烈提示（编译期抛出：产生波浪线让程序员 try catch）
		MyException 继承 Exception   在逻辑错误的地方 Throw new MyException（"这是自定义的编译期异常提示"） 
 自定义运行期异常 弱提示（在运行期才会抛出，编译期无其他操作）
		MyRuntimeException 继承 RuntimeException 在逻辑错误的地方 Throw new MyException（"这是自定义的运行期异常提示"）

	异常的优点： 提高程序的健壮性（防止因为某些异常导致程序的终止）


线程：
	一般建议同样的并行操作：将新线程代码放置到主线程上部分，这样才会发生并行操作；不然 主线程执行完之后才意识到有新线程，没起到并行的效果；

	方式1）
		1 定义一个线程类 MyThread 继承Thread
		2 重写run（）方法；
		3 新建该线程对象  Thread t = new MyThread();
		4 启动该线程对象 t.start();    
			start()底层向cpu注册新线程并触发执行；
			注意如果调用run()来启动,就是普通的 主线程调用方法而已，与多线程无关，调用start()才是发起并发线程。
	  优缺点：
			优点：1 编码简单
				  2 不能得到线程的执行结果	
			缺点：线程类已经继承了Thread类无法继承其他类了，功能不能通过继承拓展（单继承的局限性）
	
		
线程API:
	 Thread t1 = new MyThread();
	 t1.setName("我的t1线程")；//设置线程名称  默认 Thread-0  Thread-1 Thread-2 ......
	 t1.start()
	 Thread t2 = new MyThread();
	 t2.start();
	 
	 
	 
	 t1.getName(); //获取线程名称
	 t2.getName();
	 
	 t1.join();//等待让t1跑完，主线程不可以抢t1的cup(但其他子线程可以)  -->  让父线程等待子线程结束之后才能继续运行（子线程可以抢）
	 
	 Thread thisThread = Thread.currentThread(); //获取当前线程对象
	 thisThread.setName("这是主线程");
	 
	 Thread.sleep(1000);休眠 1000毫秒；
	 
	 
	 
	 
	 Thread t3 = new MyThread("wode xiancheng");//MyThread 线程对象增加有参的构造器，使用父类的有参构造器；
	 class MyThread(){
		public MyThread(String name){
			super(name);//父类的有参构造器
		}
	 }
	

   方式2） 定义一个任务类 实现Runnable接口（创建一个实现了Runnable接口的任务类，让其包装至Thread来执行）
		 缺点：1 代码复杂一点
			   2 不能得到线程的执行结果
		 优点：1 线程任务类实现了线程功能接口后 还可以继承实现其他类的功能。
			   2 同一个线程任务对象可以被包装成多个线程对象；
			   3 适合多个相同的程序代码的线程去共享同一个资源
		       4 实现解耦操作，线程任务代码可以被多个线程共享 代码和线程独立。也就是说：实现Runnable接口的MyRunnable 中线程操作被解耦出来，自由修改而被线程使用；
		 
		1 创建一个线程任务类 implements Runnable方法 重写run（）方法；
			class MyRunnabel implements RunnabnleP{
				@Override
				run(){
					
				{
			}
			
		2 创建一个线程任务对象
			Runnable myRun = new MyRunnable();
		3 把线程任务对象包装成线程对象
			Thread t = new Thread(myRun,"我的1号线程")；
		5 调用线程的start()方法启动线程
		
	 实例方式 2.1)
	    匿名内部类：我的理解是对于要实现接口的对象，正常情况是新建类->实现接口->重写方法->产生对象（多态调用 new 新建的类）->调用重写的方法|||||||
				
				如果我们在代码中 只是临时使用接口重写的方法对象，以上步骤中，生成的 类只是临时的作用，重点在于重写的方法内容，此时就可以
				使用匿名内部类来 弱化这个类 从而简化代码
		
		new Thread(new Runnable() {
            @Override
            public void run() {
                while (true){
                    System.out.println("这是"+Thread.currentThread()+"线程");
                }

            }
        },"我的线程").start();
	

	方式3) 实现 Callable接口
		优点：可获取结果；可捕获异常；解耦
		
		缺点：编码复杂
		
		1 实现 Callable接口 重写call()方法
			class MyCallable implements Callable<String>{
				@Override
				public String call() throws Exception{
					String a ="测试"
					~~~~~~~~~~~~~~
					return a;
				}
			}
		
		2 把Callable任务对象包装成一个 《未来任务对象》FutureTask<>，未来任务对象在线程执行完毕后得到线程执行的结果
			Callable myCall = new MyCallable();
			FutureTask<String> futureTask = new FutureTask<>(myCall);  //FutureTask 实现RunnableFuture 接口 (该接口继承 Runnable 接口)
		3 把未来任务对象再包装成为 线程对象
			Thread t = new Thread(futureTask)
		4 启动线程对象
			t.start();
		5 获取线程结果 //在最后去获取线程执行结果，如果线程没有结果，让出cup等待线程执行完毕再来取结果
			try{
				//可捕获异常
				String rs = futureTask.get();//获得结果
			}catch (Exception e){
				e.printStackTrace
			}
线程安全：多线程对同一资源操作时可能出现线程安全问题
	解决办法，线程同步方式：
			  1 同步代码块
			  2 同步方法
			  3 lock显示锁
	1 同步代码块		  
	  run（）{}方法中 即多线程所在的方法里 
	  //synchronized是一个类，即锁对象，唯一。 如下 ZHAO_XIN 在各个线程中被抢，同一时刻只有一个抢到，保证ZHAO_XIN内的代码块唯一；
		******但一般在高度面向对象的代码中:
				在实例方法中建议使用 this 即 synchronized(this){}：this表示本共享资源类（线程方法run（）在此共享资源类中定义，例如 run()在 本Accout.classs中）
				在静态方法中建议使用类名.class字节码作为锁对象
	  synchronized("ZHAO_XIN"//唯一对象 ){
		线程方法中对共享资源进行操作的代码块
	  }
	  
	2 同步方法 底层与同步方法块一致，只是把整个方法加锁，也是有锁对象，如果是实例方法默认this作为锁对象；如果是静态 static 方法默认为 类名.class作为锁对象
		punlic synchronized void drawMoney(account){}
		
	3 lock显示锁 
		 在资源类（多线程会共同调用的类 ）里：private final Lock lock = new ReentrantLock();
		 
	  在代码块里    
		lock.lock();
		try{
			//被锁的存在公共资源操作的代码块
		}catch(e Exception){
		
		}finally{
			lock.unlock()
		}
		

总结：线程安全，性能差；
	  线程不安全性能好。假如开发中不会存在多线程安全问题，建议使用线程不安全的设计类；
	  
	  
线程间通信：
	线程间通信一定是多个线程在操作同一资源才需要进行通信
	线程通信必须先保证线程安全，否则毫无意义，代码也会报错！ 
	
	线程通信的Object提供的核心方法：注意：****此三个方法只能在锁对象中调用****（都是对锁对象的抢夺之争）
		public void wait(): 让当前线程锁释放，进入到等待状态，等待唤醒，唤醒后继续执行之后的代码；
		public void notify(): 唤醒当前锁对象上等待状态的  某个（优先级较高的幸运儿） 线程 
		punlic void notifyAll(): 唤醒当前锁对象上等待状态的  全部 线程
	 以上：注意 代码中先执行 notify()/notifyAll() 再执行 wait(); 不然执行wait()之后，线程等待 其后的notify()此时不能被调用；
	 
线程状态：
	NEW		  新建			                              	       Blocked 阻塞（正在抢锁状态）
			
	Runnable  可运行、就绪（抢到锁；正在执行（可得到cpu））        Waiting 等待 (wait() 释放锁 无限等待，待唤醒，不唤醒一直等待,唤醒后 开始抢锁)
		        						                             Timed Waiting  计时等待（wait(1000)有限等待，时间内等待（也可被直接唤醒），时间到 开始抢锁） 
	Teminated 死亡			           
								                                   Sleep   睡眠（sleep（100） 睡眠，抱着锁不放，时间到后继续执行，其他抢锁的就得干等着人家睡觉）
																   
	
线程池：
		可理解为数据库连接池：预设一些端口统一管理，不需要频繁新建、销毁，随来随连，一个断开就可服务其他线程连接；
	优点： 1 减低资源消耗
		   2 提高响应速度
		   3 提高线程的可管理性
	 线程池框架：
		class MyRunnable implements Runnable{
			@Override
			public void Run(){
			  String name = Thread.currentThread();
			  //线程内容
			}
		}
	 
		Executorservice pools = Executors.nieFixedThreadPool(3,3,1000);//从 Executors 静态方法获得 线程池  
														参数：核心线程数（不死），最大线程数（除了核心的三个 剩下两个作为扩容，扩容的最长活跃时间（过期收回扩容的））
		Runnable target = new MyRunnable();
		
		pools.submit(target); //第一次提交任务，此时线程池创建线程
		pools.submit(target); //第二次提交任务，此时线程池创建线程
		pools.submit(target); //第三次提交任务，此时线程池创建线程
		pools.submit(target); //第四次提交任务，复用之前的线程
		
		//即便任务执行完之后 线程也不会关闭；
		
		pool.shotdown();//待线程执行完之后再停止；
		pool.shotdownNow();//不论执行完与否立即停止
	
	
	Callable做线程池的任务: 可以得到线程池的结果	
		Future<String> t1 = pools.submit(new MyCallable(100));
		Future<String> t2 = pools.submit(new MyCallable(200));
		Future<String> t3 = pools.submit(new MyCallable(300));
		Future<String> t4 = pools.submit(new MyCallable(400));
		
		try{
			//同样 获得结果会等待多有线程执行完毕 后get()返回结果；
			String rs1 = t1.get();
			String rs2 = t2.get();
			String rs3 = t3.get();
			String rs4 = t4.get();
		}catch(Exception e){
			e.printStackTrace();
		}
		
死锁 : 多个线程同时阻塞，他们中的一个或者多个在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止
		客户 拿钱 等货给钱  经销商 拿货 等钱给货
		
	java产生死锁的四个必要条件：
		1 同一个资源只能被同一个线程占有
		2 被占有的资源不可被其他前程抢取
		3 占有资源的线程在占有资源的同时 请求其他资源；
		4 循环等待，3的情况两个线程 都占有一个资源等待对方释放并占有 （尬住了）
		
Volatile 并发编程下，多线程访问变量的不可见性

	JMM （Java Memory Model 只针对于并发的内存模型）
		主内存 和 工作内存（每个线程都有自己的工作内存）
		所有共享变量都存在主内存中，线程进入工作内存后从主内存中拷贝一份至自己的工作内存（保存一份副本），然后在自己内存（线程）中操作，可以理解为缓存
	解决：1）加锁（锁会独立执行 并 同步 至主内存中 ）
				某个线程进入synchronized代码前后，执行过程如下：
					a.线程获得锁 b.清空工作内存 c.从主内存拷贝共享变量最新的值到工作内存成为副本 d.执行代码 e.将修改后的副本的值刷新回主内存中 f.线程锁释放
					   即每次加锁会清空工作内存，从新读取主内存新值
		  2）对变量增加修饰 volatile   
				工作原理：volatele 修饰的变量 在线程中发生改变时 会同步至主内存 并通知所有的工作内存 该变量发生改变，其会再从主内存同步最新值
			
				public class VolatileDemo extend Thread {
					private volatile boolean flag = false;
					
					***
				}
	volatile 与 synchronized 
		1 volatile 只能修饰实例变量 和 类变量，而synchronized可以修饰 方法 以及 代码块
		2 volatile保证数据的可见性（即保证最新值），但不保证原子性（即无法保证线程安全，不能加锁让某些资源只让一个线程执行），也就是说让你及时看到，也只是看到而已。
		

原子性 :线程安全
		指一批操作是一个整体，要么同时成功，要么同时失败，不能被干扰（volatile只能及时看，也只是看到而已，并没有原子性，应为同时大家能操作）
		
  方案1：加锁（牺牲了一定性能）
		对于共享资源 上锁；
  
  
  
  方案2：共享资源使用 原子类（乐观锁机制，底层有volatile）， 从而保证线程安全。
	原子类 : 加锁机制性能较差，为什么使用原子类性能好且性能安全呢
				原子类CAS(compare and swap 比较再交换)机制：(乐观锁机制) 其将read-modify-check-write转为原子操作，之歌原子操作直接由处理器保证；
				其实就是：每个线程操作共享资源的时候，先记录资源值 在【自操作完成后 对其修改之前】 
						  先比较 记录值是否改变(底层有volatile)，如果改变(说明已被其他线程修改)废弃此次操作，再以此方式重操作。
				毕竟同时操作共享资源的情况较少！！所以该方式能保持较高的性能！！！
				
		AtomicInteger count = new AtomicInteger();
		
		AtomicInteger
			public AtomicInteger();                     //初始化一个默认值为0原子Integer
			public AtomicInteger(int initialVal);		//初始化一个指定值的原子类型Integer
			
			int get();									//获得当前值
			int getAndIncrement();						//获得当前值 再 +1
			int incrementAndGet();						//+1后再获得增加后的值
			int getAndAdd(int value)					//获得当前值 再加指定值
			int addAndGet(int value);					//增加指定值后 再获得增加后的值
  CAS 与 syncjhronized:乐观锁 悲观锁
		乐观锁：每个线程操作很乐观，认为没人同时修改该共享资源，只是 再每次要修改(提交)前检查一下共享资源是否被操作；
		悲观锁：每个线程都很保守，我不管其他线程你们会不会同时修改该共享资源，我强制把资源上锁，只能让我操作，操作完了我再释放；
  
	
并发包：一般开发无并发无需考虑线程安全问题，某些业务必须考虑线程安全问题时我们就要使用 并发包；
	     性能优异，线程安全
		 
	HashMap   是线程不安全的，底层哈希表保存时当两个数据同时保存至同一位置时，后保存的会覆盖前一保存的内容；
	HashTable 是线程安全的，底层源代码 全加锁(synchronized),极度悲观 甚至查询方法也加锁。。。 所以性能很差，一般不会使用;
	
	ConcurrentHashMap  线程安全，是目前效率最高的线程安全集合
							原理：底层哈希表局部锁 --> 只锁链表，纵向的红黑树(只锁定桶)，横向的内存保存元素不加锁,  
	
		p.s.:课程中一个有意思的现象 用例中单纯增加Map元素时  HashTable 竟然比 ConcurrentHashMap 原理；因为用例单纯。。。。。。。
		
	CountDownLatch:可以控制线程在执行的过程等待自己，让其他线程执行完毕后唤醒自己；
		构造器： public CountDownLatch(int count) // 初始化唤醒需要 down几步。
		方法：   public void await() throws InterruptedException //让当前线程等待，必须down至0才可唤醒，其后的代码暂停；
				 public void countDown() //计数器(count)进行 -1 （down 1）
			
			CountDownLatch c = new CountDownLatch(1);
			new ThreadA(c).start();
			new ThreadB(c).start();
			
			//其后  ThreadA 的 Run(){}方法中 添加 c.await(); 线程运行时 使代码暂定，等待被唤醒
			//其后  ThreadB 的 Run(){}方法中 添加 c.countDown(); 线程运行时 使计数器减1，待计数器减少为0时唤醒 ThreadA 的 c.await()处代码
	
	CtclicBarrier 循环屏障 ：每个线程等待其他线程执行完毕后 最终触发自己执行；
							一般场景中可用于收集工作，比如个线程计数 求和 等等
	
		 CyclicBarrier c = new CtclicBarrier(5,new Meeting());
		 for(int i ; i <=5 ;i++){
			new EmployeeThread("员工"+i, c).start();
		 }
		 
		 Class Meeting implements Runnable{
			@Override
			public void run(){
				System.out.println(Thread.currentThread().getName()+ "5个线程中 挑一个 开始组织会议")
			}
		 }
		 
		 Class EmployeeThread{
			private CyclicBarrier c;//监督者 监督线程
			punlic Employee(String name,CyclicBarrier c){
				super(name);
				this.c = c;
			}
			@Override
			public void run(){
				Thread.sleep（1000）;
				System.out.println(Thread.currentThread().getName()+"进入会议室")
				
				c.await(); //每个线程调用await方法告诉CyclicBarrier我已经达到了屏障，然后当前线程被回收，
						   //当集满设置的 每 5 个线程都到达屏障时，在这5个回收的线程中 随机挑选一个 运行CyclicBarrier中Runnable重写的run()方法
			}
		 }
	
	Samapheore : 主要控制线程的并发数量      synchronized 控制并发一个 
		//新建一个锁对象
		public Semphore semaphore = new Semphore(2);//参数2 表示允许并发的数量；
		
		**将该类包装至线程运行的代码块（run()）**；
		
		semaphore.acquire();//上锁；
		
		***中间的代码块只允许设置的线程数量并发
	
		semaphore.acquire();//解锁；
	
	Exchanger :用于线程间数据交换
		  可进行数据比对
		class Boy extends Thread{

			private Exchanger<String> exchanger;
			Boy(Exchanger exchanger){
				this.exchanger = exchanger;
				super.setName("男孩");
			}
			@Override
			public void run() {
				System.out.println(Thread.currentThread().getName()+ "制作信物游戏机");
				try {
					System.out.println((Thread.currentThread().getName()+"得到"+exchanger.exchange("游戏机")));
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}

		class Girl extends Thread{

			private Exchanger<String> exchanger;
			Girl(Exchanger exchanger){
				this.exchanger = exchanger;
				super.setName("女孩");
			}
			@Override
			public void run() {
				System.out.println(Thread.currentThread().getName()+ "制作信物口红");
				try {
					System.out.println(Thread.currentThread().getName()+"得到"+exchanger.exchange("口红"));
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
		
		Exchanger<String> exchanger = new Exchanger<>();
        new Boy(exchanger).start();
        new Girl(exchanger).start();
		
		女孩制作信物口红
		男孩制作信物游戏机
		女孩得到游戏机
		男孩得到口红
		
		exchanger.exchange("游戏机",5, TimeUnit.SECONDS) 可设定交换等待市场；如果超时则产生异常：java.util.concurrent.TimeoutException
		
================================================================================================================================================

Lambda 表达式  简化代码：
		Lambda表达式只能简化接口中只有一个抽象方法的匿名内部类写法；
		函数式接口：接口中只有一个抽象方法的接口；注解未 @FunctionalInterface
		
	即 Lambda只能简化函数式接口的匿名内部类
		Thread thread = new Thread(new Runnable(){
			@Override
			punlic void run(){
			}
		});
		
		Thread t = new Thread(
			()->{
				System.out.println("我是一个开心匿名内部类的线程");
			}
		);
		
		
		
		Student a = new Student("a",132,"男");
        Student b = new Student("b",12,"女");
        Student c = new Student("c",100,"男");
        List<Student> lists = new ArrayList<>();
        Collections.addAll(lists,a,b,c);
        System.out.println(lists);
        Collections.sort(lists, (o1,o2)-> {
                return o1.getAge()-o2.getAge();
        });	
        System.out.println(lists);
		
		继续省略 如果只是一行代码：
					去掉 return 去掉{} 去掉 ;  
					参数类型可以忽略 ， 
					如果只有一个参数，同时（）也可以省略
		new Thread(()-> System.out.println("我是一个开心匿名内部类的线程"));
		Collections.sort(lists, (o1,o2)->  o1.getAge()-o2.getAge());
		lists.forEach(student -> System.out.println(student.toString()));
	
	
	特定类型方法引用：
		Arrays.sort(Strs, (s1, s2) -> s1.compareToIgnoreCase(se));
		//如果第一个参数列表中的形参中的第一个参数作为后面的方法调用者，
		//并且其余参数作为后面方法的形参，那么就可以用特定类型方法引用了
		Arrays.sort(Strs, String::compareToIgnoreCase)
		
		String[] str = lists.toArray(new IntFunction<String[]>() {
            @Override
            public String[] apply(int value) {
                return new String[value];
            }
        });
		
		String[] str = lists.toArray(s -> new String[s]);
		String[] str = lists.toArray(String[]::new);


<1.8> String 流 ：得益于1.8 lamdba所带来的函数式编程 ，Stream认为集合和数组操作的API很不好
					用来简化集合类或者数组API的弊端
					
					Stream流其实就是一根传送带，元素可以在上面被操作
		
		演示：
			List<String> lists = new ArrayList<>();
			lists.add("张无忌");
			lists.add("张三丰");
			lists.add("张浪");
			lists.add("王小明"); 
			lists.add("王一博");
			lists.add("赵昕");
			lists.stream().filter(s -> s.startsWith("张")) .filter(s -> s.length()==3) .forEach(s -> System.out.println(s));
			得到姓张 三个字 的人名
		
		核心思想：
				是先得到集合过着数组的Stream流（就是一根传送带），
				然后就用这个Stream流操作集合或者数组的元素，
				再用Stream流简化替代集合的操作
				
		Stream 流的获取：
			1 default Stream<E> Stream();
				Collection集合	
					Collection<String> c = new ArrayList<>();
					Stream<String> ss = c.stream();
				Map集合
					//先获得key的Stream流
					Stream<String> keyss = map.keySet().stream();
					//再获得值的stream流
					Stream<Strign> Valuess = map.values().stream();
					//获得键值对的Stream流（ Key=Value; Map.Entry<String,Integer> ）
					Stream<Map.Entry<String,Integer>> keyAndValues = map.entrySet().Stream();
					
				数组：
					String[] arrs = new String []{"Java","php","c"};
					Stream<String> arrsSS = Arrays.stream(arrs);
					Stream<String> arrsSS = Stream.of(arrs);
		
		Stream 流常用API
			 forEach : 逐一处理(遍历)
			 count：统计个数
				-- long count();
			 filter : 过滤元素
				-- Stream<T> filter(Predicate<? super T> predicate)
			 limit : 取前几个元素
			 skip : 跳过前几个
			 map （映射）: 加工方法（把原来的元素加工以后，从新放上去）
						-- <R> Stream<R> map(Function<? super T, ? extends R> mapper);
			 concat : 合并流。
				
			 
			 
				list.stream().filter( s -> s.length() == 3 ).filter( s -> s.startsWith("张"))
					.forEach( System.out::println);
				// 统计数量
				long count = list.stream().filter( s -> s.length() == 3 )
						.filter( s -> s.startsWith("张")).count();
				System.out.println(count);
				// 取前2个
				list.stream().filter(s -> s.length() == 3).limit(2)
						.forEach( System.out::println);
				// 跳过前2个
				list.stream().filter(s -> s.length() == 3).skip(2)
						.forEach( System.out::println);
				
				// 需求：把名称都加上“黑马的:+xxx”
				list.stream().map(a -> "黑马的："+a).forEach(System.out::println);

				// 需求：把名称都加工厂学生对象放上去!!
				// list.stream().map(name -> new Student(name)).forEach(System.out::println);
				   list.stream().map(Student::new).forEach(System.out::println);
				   
				   
				// 数组流
				Stream<Integer> s1 = Stream.of(10, 20 ,30 ,40);
				// 集合流
				Stream<String> s2 = list.stream();
				// 合并流
				Stream<Object> s3 = Stream.concat(s1,s2);
				s3.forEach(System.out::println);
				
				
		终结与非终结方法。

				终结方法：一旦Stream调用了终结方法，流的操作就全部终结了，不能继续使用，
					只能创建新的Stream操作。
					终结方法： foreach , count。

				非终结方法：每次调用完成以后返回一个新的流对象,
					可以继续使用，支持链式编程！	

				// foreach终结方法
				list.stream().filter(s -> s.startsWith("张"))
						.filter(s -> s.length() == 3).forEach(System.out::println);
				
				// count终结方法
				long count =  list.stream().filter(s -> s.startsWith("张"))
						.filter(s -> s.length() == 3).count();
				System.out.println(count);
					
		收集Stream流:把Stream流的数据转回成集合（此过程消费了流，用此流转第二次会失败）。

				引入：
					Stream的作用是：把集合转换成一根传送带，借用Stream流的强大功能进行的操作。
					但是实际开发中数据最终的形式还是应该是集合，最终Stream流操作完毕以后还是要转换成集合。
					这就是收集Stream流。

				收集Stream流的含义：就是把Stream流的数据转回到集合中去。

				Stream流：手段。
				集合：才是目的。

				小结：
					收集Stream流的含义：就是把Stream流的数据转回到集合中去。

				熟练函数式编程，如Lambda表达式简化函数式接口的匿名内部类形式，
				以及四种方法引用简化Lambda表达式，以及流式编程思想如Stream简化集合或者数组的操作。
				
			方法	
				Stream<String> zhangLists = list.stream().filter(s -> s.startsWith("张"));
				// 把stream流转换成Set集合。
				Set<String> sets = zhangLists.collect(Collectors.toSet());//注意转Set会去重
				System.out.println(sets);

				// 把stream流转换成List集合。
				Stream<String> zhangLists1 = list.stream().filter(s -> s.startsWith("张"));
				List<String> lists= zhangLists1.collect(Collectors.toList());
				System.out.println(lists);

				// 把stream流转换成数组。
				Stream<String> zhangLists2 = list.stream().filter(s -> s.startsWith("张"));
				Object[] arrs = zhangLists2.toArray();
				// 可以借用构造器引用申明转换成的数组类型！！！
				String[] arrs1 = zhangLists2.toArray(String[]::new);

File类
	 File针对目录的遍历
     - public String[] list()：
             获取当前目录下所有的"一级文件名称"到一个字符串数组中去返回。
     - public File[] listFiles()(常用)：
             获取当前目录下所有的"一级文件对象"到一个文件对象数组中去返回（重点）.
			 
		File dir = new File("D:\\itcast");
        // a.获取当前目录对象下的全部一级文件名称到一个字符串数组返回。
        String[] names = dir.list();
        for (String name : names) {
            System.out.println(name);
        }
        // b.获取当前目录对象下的全部一级文件对象到一个File类型的数组返回。
        File[] files = dir.listFiles();
        for (File file : files) {
            System.out.println(file.getAbsolutePath());
        }

        // ---------拓展------------
        File f1 = new File("D:\\itcast\\图片资源\\beautiful.jpg");
        long time = f1.lastModified(); // 最后修改时间！
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        System.out.println(sdf.format(time));
		


递归 
	递归的形式

    递归：方法在方法中又调用了自己。

    递归：
        直接递归：自己的方法调用自己。
        间接递归：自己的方法调用别的方法，别的方法又调用自己。
    小结：
         递归是自己调用自己。
         递归如果控制的不恰当，会形成递归的死循环，从而导致栈内存溢出错误！！
         递归应该防止进入递归的死循环！
	

	public static int f(int x){
        if( x == 10){
            return 1 ;
        }else{
            return 2*f(x+1)+2;
        }
    }
	
	
	

	目标：递归的核心算法思想和执行流程（重点。拓展）

    已知：f(x) = f(x - 1) + 1  （恒等式）
    已知：f(1) = 1
    求：  f(10) = ?

    计算流程：
         f(10) = f(9) +  1
         f(9)  = f(8) +  1
         f(8)  = f(7) +  1
         f(7)  = f(6) +  1
         f(6)  = f(5) +  1
         f(5)  = f(4) +  1
         f(4)  = f(3) +  1
         f(3)  = f(2) +  1
         f(2)  = f(1) +  1
         f(1)  = 1

    递归的三要素（理论）：
        1.递归的终结点： f(1)  = 1
        2.递归的公式：f(x) = f(x - 1) + 1
        3.递归的方向：必须走向终结点
	
	public static void main(String[] args) {
        System.out.println(f(10));
    }

    public static int f(int x){
        if(x == 1) {
            return 1;
        }else{
            return f(x - 1) + 1 ;
        }
    }
	
	
	
	
	
	拓展：递归的核心思想-公式转换

    已知： f(x) = f(x + 1) + 2
          f(1) = 1
    求：   f(10) = ?

    公式转换：
        f(n-1) = f(n-1+1)+2
        f(n-1) = f(n)+2
        f(n) = f(n-1)- 2 ;

    递归算法的三要素：
         （1）递归的公式：   f(n) = f(n-1)- 2 ;
         （2）递归的终结点：  f(1) = 1
         （3）递归的方向：必须走向终结点。
    小结：
        必须满足三要素，否则递归会出现死亡！
		
	public static void main(String[] args) {
        System.out.println(f(10));
    }

    public static int f(int n){
        if(n == 1) {
            return 1;
        }else{
            return f(n-1)- 2;
        }
    }
	
	
	目标：递归的经典案例。

    猴子吃桃：
        猴子第一天摘了若干个桃子，当即吃了一半，觉得好不过瘾，然后又多吃了一个。
        第二天又吃了前一天剩下的一半，觉得好不过瘾，然后又多吃了一个。
        以后每天都是如此
        等到第十天再吃的时候发现只有1个桃子，请问猴子第一天总共摘了多少个桃子。

    公式：
        f(x+1) = f(x) - f(x) / 2 - 1
        2f(x+1) = 2f(x) - f(x) - 2
        2f(x+1) = f(x) - 2
        f(x) = 2f(x+1)+2
    递归的三要素：
        （1）公式：f(x) = 2f(x+1)+2
        （2）终结点：f(10) = 1
        （3）递归的方向：走向了终结点
		
	public static void main(String[] args) {
        System.out.println(f(1));
    }
	//***************** 其实就是 ，里面写一个if else   第一个里写终结点：第二个写公式 即可 ******************
    public static int f(int x){
        if( x == 10){
            return 1 ;
        }else{
            return 2*f(x+1)+2;
        }
    }
	
	
	目标：递归实现1-n的和。

     f(n) = 1 + 2 + 3 + 4 + 5 + 6 + ...n-1 + n ;
     f(n) = f(n-1) + n

     流程：
         f(5) = return f(4)  + 5  = 1 + 2 + 3 + 4 + 5
         f(4) = return f(3)  + 4  = 1 + 2 + 3 + 4
         f(3) = return f(2)  + 3  = 1 + 2 + 3
         f(2) = return f(1)  + 2  = 1 + 2
         f(1) = return 1

     递归的核心三要素：
        （1）递归的终点接： f(1) = 1
        （2）递归的公式：  f(n) = f(n-1) + n
        （3）递归的方向必须走向终结点：
	
	public static void main(String[] args) {
        System.out.println(f(5));
    }

    public static int f(int n){
        if(n == 1 ) return 1;
        return f(n-1) + n;
    }
	
	
	目标：递归实现文件搜索(非规律递归)

    需求：希望去D:/soft目录寻找出eclipse.exe文件。

    分析：
        （1）定义一个方法用于做搜索。
        （2）进入方法中进行业务搜索分析。
    小结：
        非规律化递归应该按照业务流程开发！
		
	public static void searchFiles(File dir , String fileName){
        // 1.判断是否存在该路径，是否是文件夹
        if(dir.exists() && dir.isDirectory()){
            // 2.提取当前目录下的全部一级文件对象
            File[] files = dir.listFiles(); // null/[]
            // 3.判断是否存在一级文件对象（判断是否不为空目录）
            if(files!=null && files.length > 0){
                // 4.判断一级文件对象
                for (File f : files) {
                    // 5.判断file是文件还是文件夹
                    if(f.isFile()){
                        // 6.判断该文件是否为我要找的文件对象
                        if(f.getName().contains(fileName)){
                            System.out.println(f.getAbsolutePath());
                            try {
                                // 启动它（拓展）
                                Runtime r = Runtime.getRuntime();
                                r.exec(f.getAbsolutePath());
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                        }
                    }else{
                        // 7.该文件是文件夹，文件夹要递归进入继续寻找
                        searchFiles(f ,fileName);
                    }
                }
            }
        }
    }
	
	
	
	
	
	
	
	
	
字符输入流的使用。

     IO流的体系：
            字节流                                   字符流
     字节输入流           字节输出流               字符输入流       字符输出流
     InputStream         OutputStream            Reader         Writer                   (抽象类)
     FileInputStream     FileOutputStream        FileReader     FileWriter               (实现类)

     c.FileReader:文件字符输入流。
         -- 作用：以内存为基准，把磁盘文件的数据以字符的形式读入到内存。
            简单来说，读取文本文件内容到内存中去。
         -- 构造器：
            public FileReader(File file):创建一个字符输入流与源文件对象接通。
            public FileReader(String filePath):创建一个字符输入流与源文件路径接通。
         -- 方法：
            public int read(): 读取一个字符的编号返回！ 读取完毕返回-1
            public int read(char[] buffer):读取一个字符数组，读取多少个字符就返回多少个数量，读取完毕返回-1	
	s
        字符流一个一个字符的读取文本内容输出，可以解决中文读取输出乱码的问题。
        字符流很适合操作文本文件内容。
        但是：一个一个字符的读取文本内容性能较差！！		
	
	
	// 1.创建一个文件对象定位源文件
        // File f = new File("Day10Demo/src/dlei01.txt");
        // 2.创建一个字符输入流管道与源文件接通
        // Reader fr = new FileReader(f);
        // 3.简化写法：创建一个字符输入流管道与源文件路径接通
        Reader fr = new FileReader("Day10Demo/src/dlei01.txt");
        // 4.按照字符读取，每次读取一个字符的编号返回。
//        int code1 = fr.read();
//        System.out.print((char)code1);
//        int code2 = fr.read();
//        System.out.print((char)code2);
//        int code3 = fr.read();
//        System.out.print((char)code3);
//        int code4 = fr.read(); // 读取完毕返回-1
//        System.out.print(code4);

        // 5.while循环一个一个字符读取。
        // 定义一个变量存储一个字符的编号
        int ch ;
        while ((ch = fr.read()) != -1){
            System.out.print((char)ch);
        }
		
		
		// 读法优化，必须使用循环     // abc xyz i
        // a.定义一个字节数组代表桶   // ooo ooo o
        byte[] buffer = new byte[3];
        int len ; // 存储每次读取的字节数。
        while((len = is.read(buffer)) != -1){
            // 读取了多少就倒出多少！
            String rs = new String(buffer , 0 , len);
            System.out.print(rs);
        }
		
		
		拓展：解决字节输入流读取中文内容输出乱码的问题。

		引入：
			一个一个字节读取中文输出
			一个一个字节数组读取中文输出均无法避免乱码。
		如何实现读取可以避免乱码呢？
			1.定义一个字节数组与文件的大小刚刚一样大，然后一桶水读取全部字节数据再输出！
		小结：
			定义一个字节数组与文件的大小刚刚一样大，然后一桶水读取全部字节数据再输出！
			可以避免中文读取输出乱码，但是如果读取的文件过大，会出现内存溢出！！

			字节流并不适合读取文本文件内容输出，读写文件内容建议使用字符流。

目标：字节输出流的使用。

    IO流的体系：
            字节流                                   字符流
    字节输入流           字节输出流               字符输入流       字符输出流
    InputStream         OutputStream           Reader         Writer     (抽象类)
    FileInputStream     FileOutputStream       FileReader     FileWriter (实现类)

    a.FileOutputStream文件字节输出流
        -- 作用：以内存为基准，把内存中的数据，按照字节的形式写出到磁盘文件中去。
                 简单来说，把内存数据按照字节写出到磁盘文件中去。
        -- 构造器：
            public FileOutputStream(File file):创建一个字节输出流管道通向目标文件对象。
            public FileOutputStream(String file):创建一个字节输出流管道通向目标文件路径。
            public FileOutputStream(File file , boolean append):创建一个追加数据的字节输出流管道通向目标文件对象。
            public FileOutputStream(String file , boolean append):创建一个追加数据的字节输出流管道通向目标文件路径。
        -- 方法：
           public void write(int a):写一个字节出去 。
           public void write(byte[] buffer):写一个字节数组出去。
           public void write(byte[] buffer , int pos , int len):写一个字节数组的一部分出去。
                        参数一，字节数组；参数二：起始字节索引位置，参数三：写多少个字节数出去。
    小结：
        字节输出流只能写字节出去。
        字节输出流默认是覆盖数据管道。
        换行用： os.write("\r\n".getBytes());
        关闭和刷新：刷新流可以继续使用，关闭包含刷新数据但是流就不能使用了！
		
		
		
		
    目标：字节流做文件复制。

		字节流复制的思想：
			字节是计算机中一切文件的组成，所以
			字节流适合做一切文件的复制。
			复制是把源文件的全部字节一字不漏的转移到目标文件，只要文件前后的格式一样，绝对不会有问题。

		需求：
			原文件：D:\itcast\图片资源\meinv.jpg
			目标文件：D:\itcast\meimei.jpg
		分析步骤：
			（1）创建一个字节输入流管道与源文件接通。
			（2）创建一个字节输出流与目标文件接通。
			（3）创建一个字节数组作为桶
			（4）从字节输入流管道中读取数据，写出到字节输出流管道即可。
			（5）关闭资源！
		
		
		InputStream is = null ;
        OutputStream os = null ;
        try{
            /** （1）创建一个字节输入流管道与源文件接通。 */
            is = new FileInputStream("D:\\itcast\\图片资源\\meinv.jpg");
            /** （2）创建一个字节输出流与目标文件接通。*/
            os = new FileOutputStream("D:\\itcast\\meimei.jpg");
            /** （3）创建一个字节数组作为桶*/
            byte[] buffer = new byte[1024];
            /** （4）从字节输入流管道中读取数据，写出到字节输出流管道即可。*/
            int len = 0;
            while((len = is.read(buffer)) != -1){
                // 读取多少就倒出多少
                os.write(buffer, 0 , len);
            }
            System.out.println("复制完成！");
        }catch (Exception e){
            e.printStackTrace();
        } finally {
            /**（5）关闭资源！ */
            try{
                if(os!=null)os.close();
                if(is!=null)is.close();
            }catch (Exception e){
                e.printStackTrace();
            }
        }
		
		
		
	目标：JDK 1.7开始之后释放资源的新方式

    try-with-resources:
         try(
                // 这里只能放置资源对象，用完会自动调用close()关闭
         ){

         }catch(Exception e){
              e.printStackTrace();
         }
    什么是资源？
         资源类一定是实现了Closeable接口，实现这个接口的类就是资源
         有close()方法，try-with-resources会自动调用它的close()关闭资源。
		 
		try(
                /** （1）创建一个字节输入流管道与源文件接通。 */
                InputStream is  = new FileInputStream("D:\\itcast\\图片资源\\meinv.jpg");
                /** （2）创建一个字节输出流与目标文件接通。*/
                OutputStream os = new FileOutputStream("D:\\itcast\\meimei.jpg");
                /** （5）关闭资源！是自动进行的 */
        ){
            /** （3）创建一个字节数组作为桶*/
            byte[] buffer = new byte[1024];
            /** （4）从字节输入流管道中读取数据，写出到字节输出流管道即可。*/
            int len = 0;
            while((len = is.read(buffer)) != -1){
                // 读取多少就倒出多少
                os.write(buffer, 0 , len);
            }
            System.out.println("复制完成！");
        }catch (Exception e){
            e.printStackTrace();
        }
		
字符输入流的使用。

     IO流的体系：
            字节流                                   字符流
     字节输入流           字节输出流               字符输入流       字符输出流
     InputStream         OutputStream            Reader         Writer     (抽象类)
     FileInputStream     FileOutputStream        FileReader     FileWriter (实现类)

     c.FileReader:文件字符输入流。
         -- 作用：以内存为基准，把磁盘文件的数据以字符的形式读入到内存。
            简单来说，读取文本文件内容到内存中去。
         -- 构造器：
            public FileReader(File file):创建一个字符输入流与源文件对象接通。
            public FileReader(String filePath):创建一个字符输入流与源文件路径接通。
         -- 方法：
            public int read(): 读取一个字符的编号返回！ 读取完毕返回-1
            public int read(char[] buffer):读取一个字符数组，读取多少个字符就返回多少个数量，读取完毕返回-1
     小结：
        字符流一个一个字符的读取文本内容输出，可以解决中文读取输出乱码的问题。
        字符流很适合操作文本文件内容。
        但是：一个一个字符的读取文本内容性能较差！！
		
		
	 // 1.创建一个文件对象定位源文件
        // File f = new File("Day10Demo/src/dlei01.txt");
        // 2.创建一个字符输入流管道与源文件接通
        // Reader fr = new FileReader(f);
        // 3.简化写法：创建一个字符输入流管道与源文件路径接通
        Reader fr = new FileReader("Day10Demo/src/dlei01.txt");
        // 4.按照字符读取，每次读取一个字符的编号返回。
//        int code1 = fr.read();
//        System.out.print((char)code1);
//        int code2 = fr.read();
//        System.out.print((char)code2);
//        int code3 = fr.read();
//        System.out.print((char)code3);
//        int code4 = fr.read(); // 读取完毕返回-1
//        System.out.print(code4);

        // 5.while循环一个一个字符读取。
        // 定义一个变量存储一个字符的编号
        int ch ;
        while ((ch = fr.read()) != -1){
            System.out.print((char)ch);
        }
		
		
		// a.按照字符数组读取数据使用循环
		  char[] buffer = new char[1024]; // 1K
		  // b.定义一个整数记录每次桶读取的字符数据量。
		  int len;
		  while((len = fr.read(buffer)) != -1 ) {
			  // 读取多少倒出多少字符
			  System.out.print(new String(buffer, 0 , len));
		  }
		  
     IO流的体系：
            字节流                                   字符流
     字节输入流           字节输出流               字符输入流       字符输出流
     InputStream         OutputStream           Reader         Writer     (抽象类)
     FileInputStream     FileOutputStream       FileReader     FileWriter (实现类)

     d.FileWriter文件字符输出流的使用。
        -- 作用：以内存为基准，把内存中的数据按照字符的形式写出到磁盘文件中去。
            简单来说，就是把内存的数据以字符写出到文件中去。
        -- 构造器：
           public FileWriter(File file):创建一个字符输出流管道通向目标文件对象。
           public FileWriter(String filePath):创建一个字符输出流管道通向目标文件路径。
           public FileWriter(File file,boolean append):创建一个追加数据的字符输出流管道通向目标文件对象。
           public FileWriter(String filePath,boolean append):创建一个追加数据的字符输出流管道通向目标文件路径。
        -- 方法：
             a.public void write(int c):写一个字符出去
             b.public void write(String c)写一个字符串出去：
             c.public void write(char[] buffer):写一个字符数组出去
             d.public void write(String c ,int pos ,int len):写字符串的一部分出去
             e.public void write(char[] buffer ,int pos ,int len):写字符数组的一部分出去
     小结：
        字符输出流可以写字符数据出去，总共有5个方法写字符。
        覆盖管道：
             Writer fw = new FileWriter("Day10Demo/src/dlei03.txt"); // 覆盖数据管道
        追加数据管道：
             Writer fw = new FileWriter("Day10Demo/src/dlei03.txt",true); // 追加数据管道
        换行：
             fw.write("\r\n"); // 换行
        读写字符文件数据建议使用字符流。
		
		
		// 1.创建一个字符输出流管道通向目标文件路径
        //Writer fw = new FileWriter("Day10Demo/src/dlei03.txt"); // 覆盖数据管道
        Writer fw = new FileWriter("Day10Demo/src/dlei03.txt",true); // 追加数据管道

        // 2.写一个字符出去：public void write(int c):写一个字符出去
        fw.write(97);   // 字符a
        fw.write('b');  // 字符b
        fw.write('磊'); // 字符磊，此时没有任何问题。
        fw.write("\r\n"); // 换行

        // 3.写一个字符串出去：public void write(String c)写一个字符串出去：
        fw.write("Java是最优美的语言！");
        fw.write("我们在黑马学习它！");
        fw.write("\r\n"); // 换行

        // 4.写一个字符数组出去：public void write(char[] buffer):写一个字符数组出去
        fw.write("我爱中国".toCharArray());
        fw.write("\r\n"); // 换行

        // 5.写字符串的一部分出去: public void write(String c ,int pos ,int len):写字符串的一部分出去
        fw.write("Java是最优美的语言！",0,9);
        fw.write("\r\n"); // 换行

        // 6.写字符数组的一部分出去：public void write(char[] buffer ,int pos ,int len):写字符数组的一部分出去
        fw.write("我爱中国".toCharArray(),0 ,2);
        fw.write("\r\n"); // 换行

        fw.close();
		
		
缓冲流的概述和分类。

            字节流                                     字符流
     字节输入流               字节输出流              字符输入流            字符输出流
     InputStream             OutputStream          Reader               Writer   (抽象类)
     FileInputStream         FileOutputStream      FileReader           FileWriter(实现类)
     BufferedInputStream     BufferedOutputStream  BufferedReader       BufferedWriter(实现类，缓冲流)
                                                   InputStreamReader    OutputStreamWriter

    什么是缓冲流：缓冲流可以提高字节流和字符流的读写数据的性能。
    缓冲流分为四类：
        （1）BufferedInputStream：字节缓冲输入流，可以提高字节输入流读数据的性能。
        （2）BufferedOutStream：  字节缓冲输出流，可以提高字节输出流写数据的性能。
        （3）BufferedReader：  字符缓冲输入流，可以提高字符输入流读数据的性能。
        （4）BufferedWriter：  字符缓冲输出流，可以提高字符输出流写数据的性能。
		
		
	使用高级的缓冲字节流按照一个一个字节数组的形式复制文件 性能极好，推荐使用
	
		long startTimer = System.currentTimeMillis();
		try(
				// 1.创建一个低级的字节输入流与源文件接通
				InputStream is = new FileInputStream(SRC_FILE);
				BufferedInputStream bis = new BufferedInputStream(is);
				// 2.创建一个敌机的字节输出流管道与目标文件接通
				OutputStream os = new FileOutputStream(DEST_FIlE+"04.avi");
				BufferedOutputStream bos = new BufferedOutputStream(os);
		){
			// 3.定义一个字节数组存储字节
			byte[] buffer = new byte[1024];
			// 定义一个变量存储每次读取的字节数量。
			int len ;
			while((len = bis.read(buffer))!=-1){
				bos.write(buffer,0,len);
			}
		}catch (Exception e){
			e.printStackTrace();
		}
		long endTimer = System.currentTimeMillis();
		System.out.println("高级的字节缓冲流按照一个一个字节数组的形式复制文件耗时："+(endTimer-startTimer)/1000.0);
		
	
	字符缓冲输入流：BufferedReader
      -- 作用：字符缓冲输入流可以把字符输入流包装成一个高级的缓冲字符输入流，
               可以提高字符输入流读数据的性能。
      -- 构造器：public BufferedReader(Reader reader):
      -- 原理：缓冲字符输入流默认会有一个8K的字符缓冲池,可以提高读字符的性能。
      -- 缓冲字符输入流除了提高了字符输入流的读数据性能，
         缓冲字符输入流还多了一个按照行读取数据的功能（重点）:
             public String readLine(): 读取一行数据返回，读取完毕返回null;
     小结：
        字符缓冲输入流可以把字符输入流包装成一个高级的缓冲字符输入流，
        可以提高字符输入流读数据的性能。
        除此之外多了一个按照行读取数据的功能：
            public String readLine(): 读取一行数据返回，读取完毕返回null;
			
		// 1.定义一个原始的字符输入流读取源文件
        Reader fr = new FileReader("Day10Demo/src/dlei06.txt");

        // 3.把低级的字符输入流管道包装成一个高级的缓冲字符输入流管道
        BufferedReader br = new BufferedReader(fr);
        // 定义一个字符串变量存储每行数据
        String line;
        // 使用一个循环读取数据(经典代码)
        while((line = br.readLine())!=null){
            System.out.println(line);
        }

//        // 2.定义一个字符数组循环读取
//        char[] buffer = new char[1024];
//        int len ;
//        while((len = br.read(buffer))!=-1){
//            System.out.println(new String(buffer , 0 , len));
//        }

        br.close();
		
		
		

	 字符缓冲输入流：BufferedReader
		  -- 作用：字符缓冲输入流可以把字符输入流包装成一个高级的缓冲字符输入流，
				   可以提高字符输入流读数据的性能。
		  -- 构造器：public BufferedReader(Reader reader):
		  -- 原理：缓冲字符输入流默认会有一个8K的字符缓冲池,可以提高读字符的性能。
		  -- 缓冲字符输入流除了提高了字符输入流的读数据性能，
			 缓冲字符输入流还多了一个按照行读取数据的功能（重点）:
				 public String readLine(): 读取一行数据返回，读取完毕返回null;
		 小结：
			字符缓冲输入流可以把字符输入流包装成一个高级的缓冲字符输入流，
			可以提高字符输入流读数据的性能。
			除此之外多了一个按照行读取数据的功能：
				public String readLine(): 读取一行数据返回，读取完毕返回null;
				
					// 1.定义一个原始的字符输入流读取源文件
				Reader fr = new FileReader("Day10Demo/src/dlei06.txt");

				// 3.把低级的字符输入流管道包装成一个高级的缓冲字符输入流管道
				BufferedReader br = new BufferedReader(fr);
				// 定义一个字符串变量存储每行数据
				String line;
				// 使用一个循环读取数据(经典代码)
				while((line = br.readLine())!=null){
					System.out.println(line);
				}

				br.close();
				
				
	*************************************************
	**input/output 字节 转 字符read/write  同时来指定编码格式**
	*************************************************
	
	字符输入转换流InputStreamReader的使用。 

             字节流                                     字符流
     字节输入流               字节输出流              字符输入流            字符输出流
     InputStream             OutputStream          Reader               Writer   (抽象类)
     FileInputStream         FileOutputStream      FileReader           FileWriter(实现类)
     BufferedInputStream     BufferedOutputStream  BufferedReader       BufferedWriter(实现类，缓冲流)
                                                   InputStreamReader    OutputStreamWriter
     字符输入转换流InputStreamReader:
          -- 作用：可以解决字符流读取不同编码乱码的问题。
                  可以把原始的字节流按照当前默认的代码编码转换成字符输入流。
                  也可以把原始的字节流按照指定编码转换成字符输入流

          -- 构造器：
                public InputStreamReader(InputStream is)：可以使用当前代码默认编码转换成字符流，几乎不用！
                public InputStreamReader(InputStream is,String charset):可以指定编码把字节流转换成字符流
     小结：
         字符输入转换流可以把字节输入流按照默认编码转换成字符输入流。
            -- Reader isr = new InputStreamReader(is); // 使用当前代码默认编码UTF-8转换成字符流，几乎不用！
         字符输入转换流也可以指定编码把字节输入流转换成字符输入流。
            -- Reader isr = new InputStreamReader(is,"GBK"); // 指定编码把字节流转换成字符流
         字符输入转换流可以解决不同编码读取乱码的问题！
		 
		 
		 
	目标：字符输出转换OutputStreamWriter流的使用。

                字节流                                         字符流
     字节输入流               字节输出流              字符输入流            字符输出流
     InputStream             OutputStream          Reader               Writer   (抽象类)
     FileInputStream         FileOutputStream      FileReader           FileWriter(实现类)
     BufferedInputStream     BufferedOutputStream  BufferedReader       BufferedWriter(实现类，缓冲流)
                                                   InputStreamReader    OutputStreamWriter
     字符输出转换流：OutputStreamWriter
           -- 作用：可以指定编码把字节输出流转换成字符输出流。
                   可以指定写出去的字符的编码。
           -- 构造器：
                public OutputStreamWriter(OutputStream os) :   用当前默认编码UTF-8把字节输出流转换成字符输出流
                public OutputStreamWriter(OutputStream os , String charset):指定编码把字节输出流转换成字符输出流
     小结：
        字符输出转换流可以指定编码把字节输出流转换成字符输出流。
        从而实现指定写出去的字符编码！
		
		// 1.写一个字节输出流通向文件
        OutputStream os = new FileOutputStream("Day10Demo/src/dlei07.txt");

        // 2.把字节输出流转换成字符输出流。
        // Writer fw = new OutputStreamWriter(os); // .把字节输出流按照默认编码UTF-8转换成字符输出流。
        Writer fw = new OutputStreamWriter(os,"GBK"); // .  把字节输出流按照指定编码GBK转换成字符输出流。
        fw.write("abc我是中国人");
        fw.close();
		
		
对象序列化
目标:对象序反列化技术。

     序列化：就是把Java对象数据直接存储到文件中去。           对象 => 文件中
     反序列化：把Java对象的文件数据恢复到Java对象中。         文件中 => 对象

                   字节流                                   字符流
     字节输入流               字节输出流              字符输入流          字符输出流
     InputStream             OutputStream          Reader             Writer   (抽象类)
     FileInputStream         FileOutputStream      FileReader         FileWriter(实现类)
     BufferedInputStream     BufferedOutputStream  BufferedReader     BufferedWriter(实现类，缓冲流)
                                                   InputStreamReader  OutputStreamWriter
     ObjectInputStream       ObjectOutputStream

     对象反序列化（对象字节输入流）：ObjectInputStream
            -- 作用：读取序列化的对象文件恢复到Java对象中。
            -- 构造器：public ObjectInputStream(InputStream is)
            -- 方法：public final Object readObject()

     如果一个字段不想参数序列化：
             transient修饰该成员变量，它将不参与序列化！
     序列化版本号：
         // 加入序列版本号
         private static final long serialVersionUID = 2L;   ****serialVersionUID 此名称为java规定名称，不可修改*****
         必须序列化使用的版本号和反序列化使用的版本号一致才可以正常反序列化！否则报错！
     小结：
        对象反序列化可以把对象序列化的文件数据恢复成Java对象。
        对象反序列化使用的流是：ObjectInputStream.
	
	
		// 1.创建User用户对象  注意：对象如果想参与序列化，对象必须实现序列化接口
        User user = new User("tsgz","003197","铁扇公主");
        // 2.创建低级的字节输出流通向目标文件
        OutputStream os = new FileOutputStream("Day10Demo/src/obj.dat");
        // 3.把低级的字节输出流包装成高级的对象字节输出流ObjectOutputStream
        ObjectOutputStream oos = new ObjectOutputStream(os);
        // 4.通过对象字节输出流序列化对象：
        oos.writeObject(user);
        // 6.释放资源
        oos.close();
        System.out.println("序列化对象成功~~~~");
		
		
打印流: 目前最方便 最高效（内部包装了缓冲流） 的文件写入
		 
	目标：打印流PrintStream （字节）/ PrintWriter（字符）.

    打印流的作用：
        1.可以方便，快速的写数据出去。
        2.可以实现打印啥出去，就是啥出去。
    打印流的构造器：
        public PrintStream(OutputStream os):
        public PrintStream(String filepath):

    小结：
         打印流可以方便，且高效的打印各种数据。
         PrintStream不光可以打印数据，还可以写"字节数据"出去。
         PrintWriter不光可以打印数据，还可以写"字符数据"出去。
		 
		 写啥打啥，随意写，全部适配。
		 
		// 1.打印流PrintStream
        //OutputStream os = new FileOutputStream("Day10Demo/src/dlei08.txt");
        //PrintStream ps = new PrintStream(os);
        PrintStream ps = new  PrintStream("Day10Demo/src/dlei08.txt");
        //PrintWriter pw = new  PrintWriter("Day10Demo/src/dlei08.txt");

        ps.println(97); // 写97
        ps.println(110); // 写110
        ps.println("我在黑马快乐的调皮~~");
        ps.println(99.8);
        ps.println(false);
        ps.println('徐');

        // 写字节数据出去
        // ps.write("我爱你".getBytes());

        ps.close();
		
	目标：打印流改变输出的流向。重定向。

    System:
        public static void setOut(PrintStream out) :让系统的输出流向打印流。	
		
		System.out.println("==itheima0==");
        PrintStream ps = new PrintStream("Day10Demo/src/log.txt");//
        System.setOut(ps); // 让系统的输出流向打印流。控制台就不再打印，而写入到log.txt里

        System.out.println("==itheima1==");
        System.out.println("==itheima2==");
        System.out.println("==itheima3==");
        System.out.println("==itheima4==");
        System.out.println("==itheima5==");
		
		
Properties：属性集对象。	
	
	目标：Properties的概述和使用(框架底层使用，了解这个技术即可)。（保存数据到属性文件）

    Properties：属性集对象。
         其实就是一个Map集合。也就是一个键值对集合。但是我们一般不会当集合使用，
         因为有HashMap。
    Properties核心作用：
         Properties代表的是一个属性文件，可以把键值对的数据存入到一个属性文件中去。
         属性文件：后缀是.properties结尾的文件,里面的内容都是 key=value。

    大家在后期学的很多大型框架技术中，属性文件都是很重要的系统配置文件。
        users.properties
                admin=123456
                dlei=dlei

     需求：使用Properties对象生成一个属性文件，里面存入用户名和密码信息。

     Properties的方法：
     -- public Object setProperty(String key, String value) ： 保存一对属性。
     -- public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值
     -- public Set<String> stringPropertyNames() ：所有键的名称的集合
     -- public void store(OutputStream out, String comments):保存数据到属性文件中去
     -- public void store(Writer fw, String comments):保存数据到属性文件中去

    小结：
        属性集对象Properties实际上是一个Map集合，可以实现把键值对数据保存到
        属性文件中去！！
		
		// a.创建一个属性集对象：Properties的对象。
        Properties properties = new Properties();
        properties.setProperty("admin" , "123456");
        properties.setProperty("dlei" , "101333");
        System.out.println(properties);

        // b.把属性集对象的数据存入到属性文件中去（重点）
        OutputStream os = new FileOutputStream("Day10Demo/src/users.properties");
        /**
         * 参数一：被保存数据的输出管道
         * 参数二：保存心得。就是对象保存的数据进行解释说明！
         */
        properties.store(os , "i am very happy!!我快乐的保存了用户数据!");
		
		
		
	
	目标：Properties读取属性文件中的键值对信息。（读取）
    Properties的方法：
        -- public Object setProperty(String key, String value) ： 保存一对属性。
        -- public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值
        -- public Set<String> stringPropertyNames() ：所有键的名称的集合
        -- public void store(OutputStream out, String comments):保存数据到属性文件中去
        -- public synchronized void load(InputStream inStream):加载属性文件的数据到属性集对象中去
        -- public synchronized void load(Reader fr):加载属性文件的数据到属性集对象中去
    小结：
        属性集对象可以加载读取属性文件中的数据！
		
		// 1.创建一个属性集对象
        Properties properties = new Properties();
        System.out.println(properties);

        // 2.字节输入流加载属性文件的数据到属性集对象properties中去。
        properties.load(new FileInputStream("Day10Demo/src/users.properties"));
        System.out.println(properties);

        System.out.println(properties.getProperty("dlei"));
        System.out.println(properties.getProperty("admin"));
		

网络通信

	目标：基本软件结构。

		通信一定是基于软件结构实现的:
			1.C/S结构 ：全称为Client/Server结构，是指客户端和服务器结构。
				常见程序有ＱＱ、迅雷，IDEA等软件。

			2.B/S结构 ：全称为Browser/Server结构，是指浏览器和服务器结构。
				常见浏览器有谷歌、火狐等、软件：博学谷、京东、淘宝。
				（开发中的重点，基于网页设计界面，界面效果可以更丰富: Java Web开发）

		两种架构各有优势，但是无论哪种架构，都离不开网络的支持。网络编程，
			就是在一定的协议下，实现两台计算机的通信的技术。
			
	
	目标：网络通信的三要素。

		1.协议
			协议：计算机网络客户端与服务端通信必须事先约定和彼此遵守的通信规则。
			HTTP , FTP , TCP , UDP , SSH , SMTP。

		2.IP地址：指互联网协议地址（Internet Protocol Address），俗称IP。
				 IP地址用来给一个网络中的计算机设备做唯一的编号。

			IPv4:4个字节，32位组成。  192.168.70.70
				局域网
				城域网
				广域网（公网）

				局域网：公司内部用。
				公网：可以在任何地方访问。

			IPv6: 可以实现为所有设备分配IP  128位

			ipconfig：查看本机的IP
			  ping 检查本机与某个IP指定的机器是否联通，或者说是检测对方是否在线。
			  ping 空格 IP地址
			  ping 220.181.57.216
			  ping www.baidu.com

		  注意：特殊的IP地址： 本机IP地址.(不受环境的影响，任何时候都存在这两个ip,可以直接找本机！)
			   127.0.0.1 == localhost。

		3.端口：
			端口号就可以唯一标识设备中的进程（应用程序）了
			端口号：
			用两个字节表示的整数，它的取值范围是0~65535。
			0~1023之间的端口号用于一些知名的网络服务和应用。
			普通的应用程序需要使用1024以上的端口号。
			如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。报出端口被占用异常！！

			利用`协议`+`IP地址`+`端口号` 三元组合，
			就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。
			
	目标：网络通信的分层和协议。

		网络通信协议：通信协议是对计算机必须遵守的规则，
		只有遵守这些规则，计算机之间才能进行通信。

		-------------------------------------------------------------------------------
		应用层  ：应用程序（QQ,微信,浏览器）,可能用到的协议（HTTP,FTP,SMTP）   通常程序员只需要关心这一层
		------------------------------------------------------------------------------
		传输层  ：TCP/IP协议 - UDP协议    计算机网络工程师需要精通的协议，有些技术我们也需要精通这一层协议，
		-----------------------------------------------------------------
		网络层  ：IP协议  封装自己的IP和对方的IP和端口
		-----------------------------------------------------------------
		数据链路层 ： 进入到硬件（网）
		-----------------------------------------------------------------
		TCP/IP协议：传输控制协议 (Transmission Control Protocol)。
			TCP协议是面向连接的安全的可靠的传输通信协议。
			1.在通信之前必须确定对方在线并且连接成功才可以通信。
			2.例如下载文件、浏览网页等(要求可靠传输)

		UDP：用户数据报协议(User Datagram Protocol)。
			UDP协议是一个面向无连接的不可靠传输的协议。
			1.直接发消息给对方，不管对方是否在线，发消息后也不需要确认。
			2.无线（视频会议，通话），性能好，可能丢失一些数据！！
		
		
	目标：InetAddress类概述
			 一个该类的对象就代表一个IP地址对象。
		InetAddress类成员方法：
			 static InetAddress getLocalHost()
				* 获得本地主机IP地址对象。
			 static InetAddress getByName(String host)
				* 根据IP地址字符串或主机名获得对应的IP地址对象。
			 String getHostName()
				* 获得主机名。
			 String getHostAddress()
				* 获得IP地址字符串。	
				
	
	目标：UDP通信的使用介绍(了解即可)

		 UDP协议的特点
			 * 面向无连接的协议
			 * 发送端只管发送，不确认对方是否能收到。
			 * 基于数据包进行数据传输。
			 * 发送数据的包的大小限制64KB以内
			 * 因为面向无连接，速度快，但是不可靠。会丢失数据！

		 UDP协议的使用场景
			 * 在线视频
			 * 网络语音电话

		 UDP协议相关的两个类
			 * DatagramPacket
				 * 数据包对象
				 * 作用：用来封装要发送或要接收的数据，比如：集装箱
			 * DatagramSocket
				 * 发送对象
				 * 作用：用来发送或接收数据包，比如：码头
		 DatagramPacket类构造器
			 发送端用：
				new DatagramPacket(byte[] buf, int length, InetAddress address, int port)
				  创建发送端数据包对象
				 * buf：要发送的内容，字节数组
				 * length：要发送内容的长度，单位是字节
				 * address：接收端的IP地址对象
				 * port：接收端的端口号

			 接收端用：
				 new DatagramPacket(byte[] buf, int length)
				 * 创建接收端的数据包对象
				 * buf：用来存储接收到内容
				 * length：能够接收内容的长度

		 DatagramPacket类常用方法
			 * int getLength() 获得实际接收到的字节个数

		 DatagramSocket类构造方法
			 * DatagramSocket() 创建发送端的Socket对象，系统会随机分配一个端口号。
			 * DatagramSocket(int port) 创建接收端的Socket对象并指定端口号

		 DatagramSocket类成员方法
			 * void send(DatagramPacket dp) 发送数据包
			 * void receive(DatagramPacket p) 接收数据包

		 需求：使用UDP实现客户端发，服务端收。(了解)
		 
			System.out.println("===启动客户端===");
			// 1.创建一个集装箱对象，用于封装需要发送的数据包!
			/**
			 new DatagramPacket(byte[] buf, int length, InetAddress address, int port)
			 参数一：封装数据的字节数组。
			 参数二：发送数据的长度!
			 参数三：服务端的IP地址
			 参数四：服务端程序的端口号码。
			 */
			byte[] buffer = "今晚，约吗？".getBytes();
			DatagramPacket packet = new DatagramPacket(buffer , buffer.length
					, InetAddress.getLocalHost(),6666);

			// 2.创建一个码头对象
			// 参数可以申明客户端端口，可以有可以没有，默认会给一个端口。
			DatagramSocket socket = new DatagramSocket();

			// 3.开始发送数据包对象
			socket.send(packet);

			socket.close();
			
			
			System.out.println("==启动服务端程序==");
			// 1.创建一个接收客户都端的数据包对象（集装箱）
			/**
			 * new DatagramPacket(byte[] buffer ,int lenght):
			 * 参数一：接收数据的数组。
			 * 参数二：接收数据的数组的长度！
			 */
			byte[] buffer = new byte[1024*64];
			DatagramPacket packet = new DatagramPacket(buffer, buffer.length);

			// 2.创建一个接收端的码头对象
			DatagramSocket socket = new DatagramSocket(6666);

			// 3.开始接收
			socket.receive(packet);

			// 4.从集装箱中获取本次读取的数据量
			int len = packet.getLength();

			// 5.输出数据
			String rs = new String(buffer , 0 , len);
			System.out.println(rs);

			// 6.服务端还可以获取发来信息的客户端的IP和端口。
			String ip = packet.getAddress().getHostAddress();
			int port = packet.getPort();
			System.out.println("对方："+ip+":"+port);
			socket.close();
		
	目标：TCP可靠传输通信入门案例（非常重要）。
		 TCP/IP协议 ==> Transfer Control Protocol ==> 传输控制协议
		 TCP/IP协议的特点
		 * 面向连接的协议
		 * 只能由客户端主动发送数据给服务器端，服务器端接收到数据之后，可以给客户端响应数据。
		 * 通过三次握手建立连接，连接成功形成数据传输通道。
		 * 通过四次挥手断开连接
		 * 基于IO流进行数据传输
		 * 传输数据大小没有限制
		 * 因为面向连接的协议，速度慢，但是是可靠的协议。

		 TCP协议的使用场景
			 * 文件上传和下载
			 * 邮件发送和接收
			 * 远程登录

		 TCP协议相关的类
			 * Socket
				 * 一个该类的对象就代表一个客户端程序。
			 * ServerSocket
				 * 一个该类的对象就代表一个服务器端程序。

		 TCP通信也叫Socket网络编程，只要代码基于Socket开发，底层就是基于了可靠传输的
		 TCP通信。

		 Socket类构造方法
			 * Socket(String host, int port)
			 * 根据ip地址字符串和端口号创建客户端Socket对象
			 * 注意事项：只要执行该方法，就会立即连接指定的服务器程序，如果连接不成功，则会抛出异常。
				   如果连接成功，则表示三次握手通过。

		 Socket类常用方法
			 * OutputStream getOutputStream(); 获得字节输出流对象
			 * InputStream getInputStream();获得字节输入流对象

		 客户端的开发流程：
			 1.客户端要请求于服务端的socket管道连接。
			 2.从socket通信管道中得到一个字节输出流
			 3.通过字节输出流给服务端写出数据。
		 服务端的开发流程：
			 1.注册端口。
			 2.接收客户端的Socket管道连接。
			 3.从socket通信管道中得到一个字节输入流。
			 4.从字节输入流中读取客户端发来的数据。

		 需求：客户端发送一行数据，服务端接收一行数据！！
		 小结：
			1.客户端用Socket连接服务端。
			2.服务端用ServerSocket注册端口，接收客户端的Socket连接。
			3.通信是很严格的，对方怎么发，你就应该怎么收，对方发多少你就只能收多少。
			4.实现的面向连接的socket端到端的通信管道，一方如果出现对象，另一方会出现异常！
			
			
			// 1.客户端要请求于服务端的socket管道连接。
			// Socket(String host, int port)
			Socket socket = new Socket("127.0.0.1" , 9999);
			// 2.从socket通信管道中得到一个字节输出流
			OutputStream os = socket.getOutputStream();
			// 3.把低级的字节输出流包装成高级的打印流。
			PrintStream ps = new PrintStream(os);
			// 4.开始发消息出去
			ps.println("我是客户端，喜欢你很久了，第一次给你发消息，只想说：约吗？");
			ps.flush();
			System.out.println("客户端发送完毕~~~~");
			
	目标：开发服务器。
			 1.注册端口。
			 2.接收客户端的Socket管道连接。
			 3.从socket通信管道中得到一个字节输入流。
			 4.从字节输入流中读取客户端发来的数据。
		ServerSocket类：
			构造器：public ServerSocket(int port)
			方法：public Socket accept()：
				 -- 等待接收一个客户端的Socket管道连接请求，连接成功返回一个Socket对象		
				 
				 
				 
基本通信模型的概念介绍。
		1最朴素的，每个客户端一个线程，来个一个给个线程
		2 用线程池管理线程， 可以线程复用 来一个客户端给个线程，线程池满了 其他的先排队，等线程释放，释放后可以复用。
		3 一个线程接收无数个客户端， 一个线程管理请求数据（分配线程给有数据的请求并守护线程），
		4 一个管理请求 ，一个分配线程（不守护）给底层，分配完了接着接受其他线程，只负责丢该底层，再收到底层完成的信息。

		 1.BIO通信模式：同步阻塞式通信。（Socket网络编程也就是上面的通信架构）
				-- 同步：当前线程要自己进行数据的读写操作。（自己去银行取钱）
				-- 异步: 当前线程可以去做其他事情，（委托一小弟拿银行卡到银行取钱，然后给你）
				-- 阻塞： 在数据没有的情况下，还是要继续等待着读。（排队等待）
				-- 非阻塞：在数据没有的情况下，会去做其他事情，一旦有了数据再来获取。（柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理）
					BIO表示同步阻塞式IO，服务器实现模式为一个连接一个线程，
					即客户端有连接请求时服务器端就需要启动一个线程进行处理，
					如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。
					同步阻塞式性能极差：大量线程，大量阻塞。

		2.伪异步通信：引入了线程池。
				不需要一个客户端一个线程，可以实现1个线程复用来处理很多个客户端！
				这种架构，可以避免系统的死机，因为不会出现很多线程，线程可控。
				但是高并发下性能还是很差：a.线程数量少，数据依然是阻塞的。数据没有来线程还是要等待！

		3.NIO   new I/O  
			表示同步非阻塞IO，服务器实现模式为请求对应一个线程，
			即客户端发送的连接请求都会注册到多路复用器上，
			多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。

			 1个主线程专门负责接收客户端：
			 1个线程[c1 ,s2 ,c3,c4, ,s2 ,c3,c4,,c3,c4, ,s2 ,c3,c4]轮询所有的客户端，发来了数据才会开启线程处理
			 这种架构性能还可以！！
			 同步：线程还是要不断的接收客户端连接，以及处理数据。
			 非阻塞：如果一个管道没有数据，不需要等待，可以轮询下一个管道是否有数据！

		4.AIO表示异步非阻塞IO，服务器实现模式为一个有效请求一个线程，
			客户端的I/O请求都是由操作系统先完成IO操作后再通知服务器应用来启动线程进行处理。
			异步：服务端线程接收到了客户端管道以后就交给底层处理它的io通信。
				 自己可以做其他事情。
			非阻塞：底层也是客户端有数据才会处理，有了数据以后处理好通知服务器应用来启动线程进行处理。

	   小结：
		   各种模型应用场景：
		   BIO适用于连接数目比较小且固定的架构，该方式对服务器资源要求比较高，JDK 1.4以前的唯一选择。
		   NIO适用于连接数目多且连接比较短（轻操作）的架构，如聊天服务器，编程复杂，
				JDK 1.4开始支持。
		   AIO适用于连接数目多且连接比较长（重操作）的架构，如相册服务器，
				充分调用操作系统参与并发操作，编程复杂，JDK 1.7开始支持。			
				


Junit 
		Junit常用注解(Junit 4.xxxx版本)
             * @Test 测试方法！
             * @Before：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。
             * @After：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。
             * @BeforeClass：用来静态修饰方法，该方法会在所有测试方法之前只执行一次。
             * @AfterClass：用来静态修饰方法，该方法会在所有测试方法之后只执行一次。

            开始执行的方法:初始化资源。
            执行完之后的方法:释放资源。

         Junit常用注解(Junit5.xxxx版本)
             * @Test 测试方法！
             * @BeforeEach：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。
             * @AfterEach：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。
             * @BeforeAll：用来静态修饰方法，该方法会在所有测试方法之前只执行一次。
             * @AfterAll：用来静态修饰方法，该方法会在所有测试方法之后只执行一次。
			 
			 

反射：
	目标：反射的概念。

		反射，注解，代理，泛型是Java的高级技术，是以后框架的底层原理必须使用到的技术。

		反射：是Java独有的技术。是Java技术显著的特点。

		反射是指对于任何一个类，在"运行的时候"都可以直接得到这个类全部成分。
			在运行时,可以直接得到这个类的构造器对象。（Constructor）
			在运行时,可以直接得到这个类的成员变量对象。（Field）
			在运行时,可以直接得到这个类的成员方法对象。（Method）

		反射的核心思想和关键就是得到：编译以后的class文件对象。

		反射提供了一个Class类型，就是可以得到编译以后的class类对象。
			HelloWorld.java -> javac -> HelloWorld.class

			Class c = HelloWorld.class;


		注意：反射是工作在运行时的技术，因为只有运行之后才会有class类对象。

		小结：
			反射的核心思想和关键就是得到：编译以后的class文件对象。
			反射是在运行时获取类的字节码文件对象：然后可以解析类中的全部成分。
			
			
   目标：反射获取Class类对象。

		引入：
			反射是通过先得到编译以后的Class类对象：字节码文件。
			然后才可以得到类中的全部成分，进行一些功能设计。

		反射为一个类的全部成分都设计了一个类型来代表这个对象：
			Class : 字节码文件的类型
			Constructor : 构造器的类型
			Field : 成员变量的类型
			Method : 方法的类型

		反射技术的第一步永远是先得到Class类对象:有三种方式获取
			（1） 类名.class
			（2） 通过类的对象.getClass()方法
			（3） Class.forName("类的全限名")
					-- public static Class<?> forName(String className)

		Class类下的方法：
			 String getSimpleName(); 获得类名字符串：类名
			 String getName();  获得类全名：包名+类名
			 T newInstance() ;  创建Class对象关联类的对象,其实底层也是调用无参数构造器，已经被淘汰。
		小结：
			Class类对象的获取有三种方式：
				1.类名.class。
				2.通过类的对象.getClass()方法。
				3.Class.forName("类的全限名")。
			Class类的方法：
				String getSimpleName(); 获得类名字符串：类名
				String getName();  获得类全名：包名+类名
				
				
			// 反射的第一步永远是先得到类的Class文件对象: 字节码文件。
			// 1.类名.class
			Class c1 = Student.class;
			System.out.println(c1);

			// 2.对象.getClass()
			Student swk = new Student();
			Class c2 = swk.getClass();
			System.out.println(c2);

			// 3.Class.forName("类的全限名")
			// 直接去加载该类的class文件。
			Class c3 = Class.forName("com.itheima._03反射_获取Class类对象.Student");
			System.out.println(c3);

			System.out.println(c1.getSimpleName()); // 获取类名本身（简名）
			System.out.println(c1.getName()); // 获取类的全限名
			// Student s1 = (Student) c1.newInstance(); // 调用无参数构造器得到对象，被淘汰了！
			
	
    目标：反射_获取Constructor构造器对象.
		
		反射的第一步是先得到Class类对象。（Class文件）

		反射中Class类型获取构造器提供了很多的API:
			 1. Constructor getConstructor(Class... parameterTypes)
				根据参数匹配获取某个构造器，只能拿public修饰的构造器，几乎不用！
			 2. Constructor getDeclaredConstructor(Class... parameterTypes)
				根据参数匹配获取某个构造器，只要申明就可以定位，不关心权限修饰符，建议使用！
			 3. Constructor[] getConstructors()
				获取所有的构造器，只能拿public修饰的构造器。几乎不用！！太弱了！
			 4. Constructor[] getDeclaredConstructors()
				获取所有申明的构造器，只要你写我就能拿到，无所谓权限。建议使用！！
		小结：
			获取类的全部构造器对象： Constructor[] getDeclaredConstructors()
				-- 获取所有申明的构造器，只要你写我就能拿到，无所谓权限。建议使用！！
			获取类的某个构造器对象：Constructor getDeclaredConstructor(Class... parameterTypes)
				-- 根据参数匹配获取某个构造器，只要申明就可以定位，不关心权限修饰符，建议使用！
				
		Student student = (Student)con.newInstance();
				
	目标：反射_获取Field成员变量对象。

		 反射的第一步是先得到Class类对象。

		 1、Field getField(String name);
				根据成员变量名获得对应Field对象，只能获得public修饰
		 2.Field getDeclaredField(String name);
				根据成员变量名获得对应Field对象，只要申明了就可以得到
		 3.Field[] getFields();
				获得所有的成员变量对应的Field对象，只能获得public的
		 4.Field[] getDeclaredFields();
				获得所有的成员变量对应的Field对象，只要申明了就可以得到
		 小结：
			获取全部成员变量：getDeclaredFields
			获取某个成员变量：getDeclaredField	
			
	目标：反射——获取Method方法对象

		反射获取类的Method方法对象：
			 1、Method getMethod(String name,Class...args);
				 根据方法名和参数类型获得对应的方法对象，只能获得public的

			 2、Method getDeclaredMethod(String name,Class...args);
				 根据方法名和参数类型获得对应的方法对象，包括private的

			 3、Method[] getMethods();
				 获得类中的所有成员方法对象，返回数组，只能获得public修饰的且包含父类的

			 4、Method[] getDeclaredMethods();
				获得类中的所有成员方法对象，返回数组,只获得本类申明的方法。

		Method的方法执行：
			Object invoke(Object obj, Object... args)
			  参数一：触发的是哪个对象的方法执行。
			  参数二： args：调用方法时传递的实际参数		
				
				
				Class c = Student.class;
				System.out.println(c);
				Student s1 = new Student("赵昕",'男',28);
				System.out.println(s1.getClass());

				System.out.println(Class.forName("com.zhaoxin.Student"));

				System.out.println(c.getSimpleName());
				System.out.println(c.getName());

				//c.getConstructor();不可以拿private

				Constructor con1 = c.getConstructor(String.class,char.class,int.class);

				Constructor con = c.getDeclaredConstructor();
				for (Constructor constructor : c.getConstructors()) {
					System.out.println("public修饰的构造器:  "+constructor);
					System.out.println("         参数个数为"+constructor.getParameterCount());
					System.out.println();
				}

				for (Constructor constructor : c.getDeclaredConstructors()) {
					System.out.println("所有的构造器:  "+constructor);
					System.out.println("         参数个数为"+constructor.getParameterCount());
					System.out.println();
				}

				con.setAccessible(true);
				Student student = (Student)con.newInstance();
		//        student.setAge(29);
		//        student.setName("赵小昕");
		//        student.setSex('男');
				student.learn();
				System.out.println(student);

				Student student1 = (Student) con1.newInstance("赵昕",'男',11);
				student1.learn();
				System.out.println(student1);

				for (Field field : c.getFields()) {
					System.out.println(field);
				}

				for (Field field : c.getDeclaredFields()) {
					System.out.println(field);
				}

				Field field = c.getDeclaredField("name");
				field.setAccessible(true);
				field.set(student1,"赵日天");

				System.out.println(student1);
				System.out.println(field.get(student1));
				
	拓展
        1.反射可以破坏面向对象的封装性（暴力反射）。
        2.同时可以破坏泛型的约束性。
		
		
		// 泛型只能工作在编译阶段，运行阶段泛型就消失了，
        // 反射工作在运行时阶段。
        List<Double> scores = new ArrayList<>();
        scores.add(99.3);
        scores.add(199.3);
        scores.add(89.5);

        // 拓展：通过反射暴力的注入一个其他类型的数据进去。
        // a.先得到集合对象的Class文件对象
        Class c = scores.getClass();
        // b.从ArrayList的Class对象中定位add方法
        Method add = c.getDeclaredMethod("add", Object.class);
        // c.触发scores集合对象中的add执行（运行阶段，泛型不能约束了）
        add.invoke(scores,"波仔");

        System.out.println(scores);
	
	
	

	拓展：反射的作用

		 可以在运行时得到一个类的全部成分然后操作。
		 可以破坏封装性。
		 也可以破坏泛型的约束性。

		 更重要的用途是适合：做Java高级框架，基本上主流框架都会基于反射设计一些通用技术功能。

		 Mybatis框架：
			 你给任何一个对象数据我都可以直接帮你解析字段并且把对应数据保存起来。
			 Student (注册，把信息字段都存储起来)
			 Teacher (注册，把信息字段都存储起来)
			 Manager (注册，把信息字段都存储起来)

			 我现在用反射技术开发一个框架实现：
			 任何对象只要给我，我就可以把信息和字段都解析并存储起来。
		 小结：
			反射适合做通用技术框架的底层实现，在框架的底层源码中我们经常看到反射的影子!!
		
		public class Mybatis {
			// 提供一个方法：可以保存一切对象数据的字段和具体值
			public static void save(Object obj) {
				try(
						PrintStream ps =
								new PrintStream(new FileOutputStream("Day12Demo/src/datas.txt",true));
				  ){
					// 解析对象的字段和每个字段的值存储起来！
					// obj = Student/Pig/Teacher....
					// 1.先得到对象的Class文件对象
					Class c = obj.getClass();
					ps.println("========="+c.getSimpleName()+"===========");
					// 2.定位它的全部成员变量
					Field[] fields = c.getDeclaredFields();
					// 3.遍历这些字段并且取值
					for (Field field : fields) {
						// 字段名称
						String name = field.getName();
						// 字段的值
						field.setAccessible(true); // 暴力反射！
						String value = field.get(obj)+"";
						ps.println(name+"="+value);
					}
				}catch (Exception e){
					e.printStackTrace();
				}

			}
		}
		
		Student s1 = new Student(1,"赵敏",26,'女' ,"光明顶","110");
        Mybatis.save(s1);

        Pig peiQi = new Pig("佩奇",500.0 , "粉色","小红","母猪");
        Mybatis.save(peiQi);




·主页 >> 子夜卷宗 >> 子夜文集 >> 《资治通鉴》第二十八卷·译文	



 
 
  	
《资治通鉴》第二十八卷·译文

原著/〔西汉〕司马光　译文/璞如子　2017年02月18日　子夜星网站

 
　　【译注者按】现今网络有《资治通鉴》全译本，但第二十八卷译文缺失，笔者搜遍网络未果，故而试译之。原文参照光绪本《资治通鉴》（影印）校对，生僻处选附原注，或另加按语以说明。译文以直译为主，意译为辅，尽量贴切原文口气。此译文仅供读者借鉴参考。


　　● 汉纪二十　〔起昭阳作噩，尽屠维单阏，凡七年。〕

　　【原文】

　　汉孝元皇帝·上

　　〔〖胡三省注〗荀悦曰：讳“奭”之字曰“盛”。应劭曰：谥法：行义悦民曰元。〕

　　汉孝元皇帝　初元元年（癸酉，公元前48年）

　　春，正月，辛丑，葬孝宣皇帝于杜陵；〔〖胡三省注〗臣瓒曰：自崩至葬凡二十八日。杜陵在长安南五十里。〕赦天下。

　　三月，丙午，立皇后王氏，封后父禁为阳平候。〔〖胡三省注〗《恩泽侯表》：阳平侯食邑于东郡。〕

　　以三辅、太常、郡国公田及苑可省者振业贫民；〔〖胡三省注〗太常掌诸陵邑，故亦有公田苑。师古曰：振业，振起之令有作业。〖按〗三辅：西汉时期位于京畿之地的三个直辖区，即中京兆（长安一代）、左冯翊（东府渭南一代）、右扶风（西府宝鸡一代）。〕赀不满千钱者，赋贷种、食。〔〖胡三省注〗师古曰：赋，给与之也。贷，假也。种，音之勇翻。贾公彦曰：种食者，或为种子，或为食用。〕

　　封外祖父平恩戴侯同产弟子中常侍许嘉为平恩侯。〔〖胡三省注〗文颖曰：戴侯，许广汉。諡法，礼不愆曰戴。余按：广汉先坐腐刑，及薨，无后；今以嘉绍封。《百官表》：侍中、中常侍皆加官。西都参用士人，东都始以宦者为中常侍。〕

　　夏，六月，以民疾疫，令太官损膳，减乐府员，省苑马，以振困乏。〔〖胡三省注〗乐府员大凡八百二十九人，武帝所立。《汉官仪》：牧师诸苑三十六所，分置北边、西边，养马三十万匹。〕

　　秋，九月，关东郡国十一大水，饥，或人相食。转旁郡钱谷以相救。

　　【译文】

　　汉孝元皇帝·上

　　汉元帝初元元年（癸酉　公元前48年）

　　春季，正月辛丑日（四日），汉宣帝刘洵被安葬在杜陵。大赦天下。

　　三月，丙午日（三月十日），汉元帝刘奭封王政君为皇后，封王政君的父王禁为阳平候。

　　以三辅、太常、各郡国公田及林苑方面减省下来的资费帮助贫民恢复家业；家产不满一千钱的，借贷给种子和粮食。

　　汉元帝刘奭封外祖父平恩戴侯许广汉同胞弟弟的儿子许嘉为平恩侯。

　　夏季，六月，因民间瘟疫流行，汉元帝刘奭命掌管后勤的太官削减膳食经费，缩编乐府成员，省掉皇家林苑的马匹，用以救济贫困的百姓。

　　秋季，九月，函谷关以东十一个郡国发生大水灾，出现饥荒，或有人吃人现象。调运周边相邻郡国的钱粮予以救济。

　　【原文】

　　上素闻琅邪王吉、贡禹皆明经洁行，〔〖胡三省注〗《姓谱》：贡姓，子贡之后。〕遣使者征之。吉道病卒。禹至，拜为谏大夫。上数虚己，问以政事。〔〖胡三省注〗《易·咸卦》：君子以虚受人。师古曰：虚己，谓听受其言也。〕

　　禹奏言：

　　“古者人君节俭，什一而税，亡它赋役，故家给人足。高祖、孝文、孝景皇帝，宫女不过十馀人，厩马百馀匹。后世争为奢侈，转转益甚；臣下亦相放效。〔〖胡三省注〗师古曰：放，音甫往翻；下同。〖按〗放，古同仿，通用。〕臣愚以为如太古难，宜少放古以自节焉。方今宫室已定，无可奈何矣；其馀尽可减损。

　　“故时齐三服官，输物不过十笥；〔〖胡三省注〗李斐曰：齐国旧有三服之官，春献冠帻縰，为首服，纨素为冬服，轻绡为夏服，凡三。如淳曰：《地理志》曰：齐冠带天下。胡公曰：服官，主作文绣以给衮龙之服。《地理志》，襄邑亦有服官。师古曰：齐三服官，李说是也。縰，与纚同，音山尔翻，即今之方目紗也。纨素，今之绢也。轻绡，今之轻紗也。襄邑自出文绣，非齐三服也。〕方今齐三服官，作工各数千人，一岁费数巨万，〔〖胡三省注〗万万为巨万。〕厩马食粟将万匹。武帝时，又多取好女至数千人，以填后宫。及弃天下，多藏金钱、财物，鸟兽、鱼鳖凡百九十物，又皆以后宫女置于园陵。至孝宣皇帝时，陛下恶有所言，〔〖胡三省注〗师古曰：不能自言减省之事。恶，乌路翻。恶有所言者，恶以天下俭其亲。此语承上园陵事。〕群臣亦随故事，甚可痛也！

　　“故使天下承化，取女皆大过度。〔〖胡三省注〗师古曰：取，读曰娶。〕诸侯妻妾或至数百人，豪富吏民畜歌者至数十人，〔〖胡三省注〗此所谓取女过度也。〕是以内多怨女，外多旷夫。〔〖胡三省注〗师古曰：旷，空也。室家空也。〕及众庶葬埋，皆虚地上以实地下。其过自上生，〔〖胡三省注〗师古曰：自，从也。上，谓天子也。〕皆在大臣循故事之罪也。唯陛下深察古道，从其俭者。大减损乘舆服御器物，三分去二；择后宫贤者，留二十人，馀悉归之，及诸陵园女无子者，宜悉遣。〔〖胡三省注〗汉制：天子晏驾，后宫送葬，因留奉陵寝。〕厩马可无过数十匹，独舍长安城南苑地，以为田猎之囿。〔〖胡三省注〗师古曰：舍，置也。独留置之，其余皆废去。舍，读曰捨。〕方今天下饥馑，可无大自损减以救之称天意乎？天生圣人，盖为万民，非独使自娱乐而已也。”

　　天子纳善其言，下诏，令诸宫馆希御幸者勿缮治，太仆减谷食马，水衡省肉食兽。〔〖胡三省注〗太仆，掌舆马。《汉旧仪》云：天子六廏，未央、丞华、辂軨、骑马、騊駼、大廏也；马皆万匹。水衡都尉，掌上林苑，禽兽属焉。师古曰：缮，补也。减，谓损其数。省者，全去之。〖按〗光绪本及它本作“水衡减肉食兽”。据师古注，可知原文应为“水衡省肉食兽”，因改。〕

　　〔〖按〗“齐三服官”：西汉时，齐、鲁一带丝织业发达，政府在齐郡临淄（今山东淄博东北临淄镇北）和陈留郡襄邑（今河南睢县）两地设置“服官”，为皇室专门制作高级丝织服物。襄邑服官刺绣好于机织，主作皇帝礼服。临淄服官则机织胜于刺绣，主作宫廷所需的其它衣料；春献冠帻徙（方目纱）为首服，纨素（绢）为冬服，轻绡（轻纱）为夏服，故临淄服官又称“齐三服官”。因每年耗资巨大，经贡禹奏请，元帝乃于初元五年（公元前44年）下诏停办。不久，又被恢复。哀帝绥和二年（公元前7年）又诏齐三服官“止作勿输”，但实际未完全罢止。〕

　　【译文】

　　汉元帝一向听说琅邪郡的王吉、贡禹二人，都通晓经典而且品行高洁，便派遣使节征召他们。王吉在途中病逝。贡禹到后，拜为谏议大夫；皇上多次虚己待人，向他请教国家政事。

　　贡禹启奏道：

　　“古代君王讲究节俭，除了征收十分之一的赋税外，便没有其它赋税徭役了，故而户户人家供给充足。高祖、孝文、孝景皇帝，宫女不过十多人，马厩里的御马不过百余匹。但后世却争比奢侈，渐渐地越加严重，下臣们也跟着相互仿效。愚臣认为：完全如太古君王那样是难以做到的，至少应效仿近古君王来自我节制一些。如今，宫室已经修定，是无可奈何了，而其余的开支还须尽可能地削减。

　　“古者人君节俭，什一而税，亡它赋役，故家给人足。高祖、孝文、孝景皇帝，宫女不过十馀人，厩马百馀匹。后世争为奢侈，转转益甚，臣下亦相放效。〔〖胡三省注〗师古曰：放，音甫往翻；下同。〖按〗放，古同仿，通用。〕臣愚以为如太古难，宜少放古以自节焉。方今宫室已定，无可奈何矣，其馀尽可减损。

　　“旧时‘齐三服官’部门，供给御用物质不过十箱。而今‘齐三服官’部门，工匠差役达数千人，一年的资费达数万，连喂食粮谷的圈马就将近一万匹。汉武帝时，又广泛选取美女达数千人，以充实后宫；到其逝世，随葬的金钱、财物，鸟兽、鱼鳖等多达一百九十种，还将后宫嫔妾侍女都置放于茂陵园内进行陪陵。即使到汉宣帝归入陵寝时，皇上也不愿言及撤免此事，群臣也附从这种旧例，真是太令人痛心了！

　　“所以，想让天下人承蒙教化，这样征收美女都大大超量了。各王侯的妻妾或达到数百人，富豪、官员们蓄养的歌妓也有数十人，所以造成禁室内多有悲怨之女，外面民间多有独身之男。等到这些王侯、官豪死后埋葬，又无不刮空地上的宝物以充实地下墓穴。这种问题始于君主，全是由于大臣们附和旧例之罪。我认为陛下深刻体察古圣人之道，会遵从其节俭之风。应大量削减车辇驾驭等器物，三分去掉其二；于后宫嫔妾侍女中择选有贤德的，留下二十人，其余全部放归回家。至于陪陵中的女子，凡没有生育过的，应全部遣返。马厩中饲养的御马可不超过数十匹，只留出长安城南一片园区，作为田园狩猎场。考虑到当今天下处于饥荒之年，若不大加削减自己的享用去解救，怎能迎合天意呢？上天降生圣人，是为了让他照顾黎民百姓，并非仅是为了他自己的享乐。”

　　天子赞许并采纳贡禹之言，颁布诏书，命令各处原预备招待天子的宫馆不再修缮置办。掌管车马之处，裁减消耗梁谷的马匹；掌管豢养禽兽的上林苑处，撤掉以肉为食的禽兽。

　　【原文】

　　臣光曰：忠臣之事君也，责其所难，则其易者不劳而正；补其所短，则其长者不劝而遂。孝元践位之初，虚心以问禹，禹宜先其所急，后其所缓。然则优游不断，谗佞用权，当时之大患也，而禹不以为言；恭谨节俭，孝元之素志也，而禹孜孜而言之，何哉？使禹之智不足以知，乌得为贤？知而不言，为罪愈大矣。

　　匈奴呼韩邪单于复上书，言民众困乏。诏云中、五原郡转谷二万斛以给之。

　　是岁，初置戊己校尉，使屯田车师故地。〔〖胡三省注〗师古曰：戊己校尉者，镇安西域，无常治处，亦犹甲乙等各有方位，而戊与己四季寄王，故以名官也。时有戊校尉，又有己校尉。一说：戊与己位在中央，今所置校尉在三十六国之中，故曰戊己也。余谓车师之地不在三十六国之中，当从师古前说为是。宣帝元康二年，以车师地与匈奴。今匈奴款附，故复屯田故地。〕

　　【译文】

　　臣司马光认为：忠臣辅助君主时，帮他解决了难办的问题，则其简单的问题不用费力就自然端正过来；弥补了他不足的方面，则其长处的一面不必奉劝，自然就发挥出来。汉元帝刚刚登位时，虚心请教贡禹，贡禹本应该先从其面临的急切的问题着手，然后再处理其不急的问题。然而优柔寡断、奸佞弄权，正是当时的大患，而贡禹却避而不谈；谦恭节俭，本是汉元帝平时所坚持的，而贡禹竟不厌其烦地说这些，为什么呀？若是贡禹的智慧不足以明白要害问题，怎能称为贤臣？若是明白要害问题而不说，则他的罪过就更大了。

　　匈奴呼韩邪单于再次上书，诉说百姓贫困。朝廷颁发诏书，责令云中、五原二郡调拨粮谷二万斛用以救济。

　　这一年，首次设置“戊己校尉”一职，使其负责驻守并农垦于车师旧地的军队。

　　【原文】

　　汉孝元皇帝　初元二年（甲戌　公元前47年）

　　春，正月，上行幸甘泉，郊泰畤。

　　乐陵侯史高以外属领尚书事，前将军萧望之、光禄大夫周堪为之副。望之名儒，与堪皆以师傅旧恩，天子任之，数宴见，言治乱，陈王事。望之选白宗室明经有行散骑、谏大夫刘更生给事中，〔〖胡三省注〗明经有行，言其通于经术，且行修饬也。〕与侍中金敞并拾遗左右。四人同心谋议，劝导上以古制，多所欲匡正，上甚鄉纳之。〔〖胡三省注〗师古曰：鄉，读曰嚮（向）。意信向之而纳用其言。〖按〗鄉，嚮之略笔，于此不可从简作“乡”。嚮，今简作“向”。〕史高充位而已，由此与望之有隙。

　　中书令弘恭、〔〖胡三省注〗弘，姓也。卫有大夫弘演。〕仆射石显，自宣帝时久典枢机，明习文法；〔〖胡三省注〗《续汉志》：尚书令，承秦所置；武帝用宦者，更为中书谒者令。成帝用士人，复故。令掌凡选署及奏下尚书曹文书众事。仆射，署尚书事，令不在则奏下众事。辩已见前。〕帝即位多疾，以显久典事，中人无外党，〔〖胡三省注〗师古曰：少骨肉之亲，无婚姻之家也。〕精专可信任，遂委以政，事无小大，因显白决；〔〖胡三省注〗白，奏也。决，断也。〕贵幸倾朝，百僚皆敬事显。显为人巧慧习事，能深得人主微指，内深贼，持诡辩以中伤人，〔〖胡三省注〗师古曰：诡，违也。违道之辩。中，竹仲翻。〕忤恨睚眦，辄被以危法。〔〖胡三省注〗忤，五故翻。睚，五懈翻。眦，仕懈翻。师古曰：被，加也，音皮义翻。危法，谓以法危杀之。〕亦与车骑将军高为表里，议论常独持故事，不从望之等。

　　【译文】

　　汉元帝初元二年（甲戌　公元前47年）

　　春，正月，汉元帝驾临甘泉，郊祭天神于泰畤。

　　乐陵侯史高以外姓亲属身份领任尚书职事，前将军萧望之、光禄大夫周堪担任其副职。萧望之是一代名儒，他与周堪都因为皇帝感念往日的师傅之恩，而被委以重任，并数次宴请接见，谈治理动乱，讲述帝王方面的事。萧望之奏请推荐皇族中通晓经典、有品行的散骑、谏议大夫刘更生做给事中，与侍中金敞一起担任皇帝左右拾遗之职。四人同心谋划计议，用古代的制度劝勉引导皇上，有很多东西希望得以匡扶纠正，皇帝甚是赞同并采纳他们的意见。史高的尚书位置不过成了摆设，由此与萧望之有了嫌隙。

　　中书令弘恭、仆射石显，自宣帝时长期按理中枢机要，熟悉条文法令。汉元帝即位时多病，因石显长期按理中枢机要一职，且内中没有外亲朋党瓜葛，办事精专可信，遂托付管理朝政，事无大小，都根据他的奏疏决断；其显贵宠幸程度为朝廷之最，朝廷百官都恭敬地从事于他。石显为人乖巧聪慧会做事，能深深领会君主的心思；内心阴险狠毒，善用诡辩中伤他人，有违逆不服者则处以严刑。石显又和车骑将军史高内外呼应，议论朝政时经常独自坚持旧例，不听从萧望之等人的意见。

　　【原文】

　　望之等患苦许、史放纵，又疾恭、显擅权，建白以为：“中书政本，国家枢机，〔〖胡三省注〗师古曰：建白者，立此议而白之。〕宜以通明公正处之。武帝游宴后庭，故用宦者，非古制也。宜罢中书宦官，应古不近刑人之义。”〔〖胡三省注〗师古曰：礼，刑人不在君侧，故曰应古。〕由是大与高、恭、显忤。上初即位，谦让，重改作，〔〖胡三省注〗师古曰：重，难也；未欲更置士人于中书也。〕议久不定，出刘更生为宗正。〔〖胡三省注〗散骑、给事中，中朝官也；宗正，外朝官也，故云出。〕

　　望之、堪数荐名儒、茂材以备谏官。会稽郑朋阴欲附望之，上书言车骑将军高遣客为奸利郡国，及言许、史弟子罪过。章视周堪，〔〖胡三省注〗师古曰：视，读曰示。以朋所奏之章示堪也。〕堪白：“令朋待诏金马门。”朋奏记望之曰：“今将军规橅，云若管、晏而休，遂行日昃，至周、召乃留乎？〔〖胡三省注〗师古曰：问望之，立意当趣如管、晏而止，为欲恢廓其道，日昃不食，追周、召之迹然后已乎﹖橅，读曰模，其字从木。〖按〗橅，通模。〕若管、晏而休，则下走将归延陵之皋，没齿而已矣。〔〖胡三省注〗应劭曰：下走，仆也。张晏曰：吴公子札食邑延陵，薄吴王之行，弃国而耕于皋泽。朋云望之所为但如管、晏，则不处汉朝，将归会稽，寻延陵之轨，隐耕皋泽之中也。师古曰：下走，自谦，言趋走之使也。没齿，终身也。〕如将军兴周、召之遗业，亲日昃之兼听，则下走其庶几愿竭区区奉万分之一！”〔〖胡三省注〗召，读曰邵。庶几，居希翻。〕望之始见朋，接待以意；〔〖胡三省注〗师古曰：与之相见，纳用其说也。余谓接待以意者，推诚待之，接以殷勤。〕后知其倾邪，绝不与通。朋，楚士，怨恨，〔〖胡三省注〗张晏曰：朋，会稽人，会稽并属楚。苏林曰：楚人脆急也。〕更求入许、史，推所言许、史事，曰：“皆周堪、刘更生教我；我关东人，何以知此？”于是侍中许章白见朋。朋出，扬言曰：“我见言前将军小过五，大罪一。”〔〖胡三省注〗前将军，谓望之也。〕待诏华龙行污秽，〔〖胡三省注〗师古曰：华，音胡化翻。姓也。〕欲入堪等，堪等不纳，亦与朋相结。

　　【译文】

　　萧望之、刘更生等人为外亲许嘉、史高的放纵感到忧虑，又苦于中书宦官弘恭、石显的专权，上奏建言认为：“中书是主持朝中政事的基础部门，是国家枢纽机关，应该以通明公正者来任职。汉武帝时游赏设宴于后宫，故而任用宦官，这并非古人制度。应该罢免中书部门的宦官，以顺应古人不亲近阉人的做法。”从此与史高、弘恭、石显这些人更加对立。皇上刚刚即位，好谦逊礼让，难于有更改之举，久议而不决，只好调出刘更生担任宗正，掌管王室亲族的事务去了。

　　萧望之、周堪多次举荐名儒、大材之人来充实谏议之官。会稽郡的郑朋暗中想攀附萧望之，便上疏举报车骑将军史高派遣宾客到郡国里做坏事谋求私利，还谈到许、史两家子弟的罪过。皇帝把奏章交给周堪看，周堪上奏道：“让郑朋在金马门等待旨意。”郑朋给萧望之上书说：“今将军所遵循的目标，是如管仲、晏子那样就行呢？还是像废寝忘食地勤于政事的周公、召公那样呢？如果像管仲、晏子那样就行了，则在下将学季札那样归隐延陵山野，直到老朽而终。如果将军有志于复兴周公、召公的事业，亲自日夜操劳，兼听各种意见，则在下愿竭尽区区之力，以效力大业于万分之一。”萧望之便会见了郑朋，诚意接待；当后来知道此人奸邪不正，便断绝关系，不与他来往。郑朋，楚地士人，因怀恨在心，转身请求投靠许嘉、史高，推诿前番参劾他们二人之事称：“都是周堪、刘更生教我说的。我一个关东人，何以知道这些事？”于是侍中许章奏请皇帝召见郑朋。郑朋出宫后扬言说：“我被召见了，报告了前将军小过五条，大罪一条。”华龙在宣帝时曾是待诏之职，因品行污秽不被任用，便想入投周堪等人，周堪等人不予接纳，华龙又与郑朋相勾结。

　　【原文】

　　恭、显令二人告望之等谋欲罢车骑将军、疏退许、史状，〔〖胡三省注〗车骑将军，谓史高。疏，与疎同。〕候望之出休日，〔〖胡三省注〗汉制：自三署郎以上入直禁中者，十日一出休沐。〕令朋、龙上之。事下弘恭问状，望之对曰：“外戚在位多奢淫，欲以匡正国家，非为邪也。”恭、显奏：“望之、堪、更生朋党相称举，数谮诉大臣，毁离亲戚，欲以专擅权势。为臣不忠，诬上不道。请谒者召致廷尉。”时上初即位，不省召致廷尉为下狱也，〔〖胡三省注〗省，悉井翻，察也，悟也。〕可其奏。后上召堪、更生，曰：“系狱。”上大惊曰：“非但廷尉问邪？”以责恭、显，皆叩头谢。上曰：“令出视事。”恭、显因使史高言：“上新即位，未以德化闻于天下，而先验师傅。即下九卿、大夫狱，〔〖胡三省注〗刘更生为宗正，九卿也。周堪为光禄大夫。〕宜因决免。”于是制诏丞相、御史：“前将军望之，傅朕八年，〔〖胡三省注〗宣帝五凤二年，萧望之为太子太傅，至黄龙元年为八年。〕无它罪过。今事久远，识忘难明，〔〖胡三省注〗师古曰：言不能尽记，有遗忘者，故难明。〕其赦望之罪，收前将军、光禄勋印绶；及堪、更生皆免为庶人。”

　　【译文】

　　弘恭、石显令使华龙和郑朋二人告萧望之等人的状，说他们想要罢免车骑将军并疏远许、史两家，并且等待萧望之出朝休假之日，指使郑朋、华龙二人奏上。皇上指派弘恭过问此状，萧望之应对道：“外亲在职于官位的多是骄奢淫逸。我是想匡扶国家走上正道，不是为了做阴邪之事。”弘恭、石显趁机上奏道：“萧望之、周堪、刘更生，他们朋党之间相互标榜举荐，多次以诬陷之辞状告大臣，离间破坏亲戚关系，是想专权夺势。为臣不忠，污蔑皇上无道。请传达旨令的人将他们传唤到廷尉那里。”此时皇上刚刚即位，不懂得传唤到廷尉即是下牢狱，便准了他们的奏请。后来皇上召见周堪、刘更生，被告知“羁押在狱。”皇上大惊道：“不就是让廷尉问明情况吗？”因而责备弘恭、石显，二人都叩头谢罪。皇上说：“让他们出来做事！”弘恭、石显便让史高说道：“皇上刚即位，尚未有仁德感化之事传闻于天下人，就先从皇帝师傅开始吧。既然把九卿、大夫下了牢狱，应该通过判决来免罪。”于是皇上制定诏书给丞相和御史道：“前将军萧望之，教导朕八年，没有其它罪过。今天所追究之事久远，记不清的事已难以辨明。赦免萧望之的罪过，收回他的前将军、光禄勋印绶，同周堪、刘更生二人都罢免为庶人。”

　　【原文】

　　二月，丁巳，立弟竟为清河王。〔〖胡三省注〗《考异》曰：荀纪，"竟"作"宽"，今从《汉书》。〕

　　戊午，陇西地震，败城郭、屋室，压杀人众。〔〖胡三省注〗《考异》曰：《刘向传》云："三月，地大震。"今从元纪。〕

　　三月，立广陵厉王子霸为王。〔〖胡三省注〗宣帝五凤四年，广陵厉王胥以罪自杀，国除。今复立其子。〕

　　诏罢黄门乘舆狗马，〔〖胡三省注〗师古曰：黄门，近署也，故亲幸之物属焉。《百官表》：黄门寺，属少府。〕水衡禁囿、〔〖胡三省注〗《百官表》：水衡都尉属官有禁圃等九官令、丞。〕宜春下苑、〔〖胡三省注〗孟康曰：宜春，宫名也，在杜县东。晋灼曰：《史记》云：葬二世杜南宜春苑中。师古曰：宜春下苑，即今京城东南隅曲江池是。〕少府佽飞外池、〔〖胡三省注〗《百官表》：少府属官有左弋十二官令、丞。武帝太初元年，更名左弋为佽飞。佽飞，掌弋射，有九丞、两尉。如淳曰：佽飞，具矰缴以凫雁，给祭祀，是故池也。佽飞，荆人，入水斩蛟，勇士也，故以名官。佽，音次。〕严籞池田，〔〖胡三省注〗苏林曰：严饰池上之屋及其地也。晋灼曰：严籞，射苑也。许慎曰：严，弋射所蔽也。池田，苑中田也。师古曰：晋说是也。〕假与贫民。又诏赦天下，举茂材异等、直言极谏之士。

　　夏，四月，丁巳，立子骜为皇太子。待诏郑朋荐太原太守张敞，先帝名臣，宜傅辅皇太子。上以问萧望之，望之以为敞能吏，任治烦乱，材轻，非师傅之器。〔〖胡三省注〗敞传云：敞无威仪，罢朝会过，走马章台街，使御吏驱，自以便面拊马；又为妇画眉。所谓材轻也。任，音壬。治，直之翻。〕天子使使者征敞，欲以为左冯翊，会病卒。

　　诏赐萧望之爵关内侯，给事中，朝朔望。〔〖胡三省注〗朝，直遥翻。《考异》曰：元纪，此诏在今冬。按《刘向传》云：“前弘恭奏望之等狱决；三月，地大震。”然则望之等黜免，在今春地震前也。又曰：“夏，客星见昴、卷舌间。上感悟，下诏赐望之爵关内侯。”望之传曰：“后数月，赐望之爵关内侯。”盖纪见望之死在十二月，因置此诏于上耳。〕

　　关东饥，齐地人相食。

　　秋，七月，己酉，地复震。〔〖胡三省注〗复，扶又翻；下同。《考异》曰：《刘向传》曰：“冬，地复震。”元纪，此月诏曰：“一年中地再动。”汉纪在七月己酉。今从之。〕

　　【译文】

　　二月，丁巳，皇帝刘奭封兄弟刘竟为清河王。

　　戊午日，陇西地区发声地震，城墙、屋室毁坏，压死了很多民众。

　　三月，封广陵厉王刘胥的儿子刘霸为广陵孝王。

　　下诏取消黄门的车乘狗马，及水衡禁囿、宜春下苑、少府佽飞外池、严籞池田等处遊乐场所，以接济贫民。又颁布诏令大赦天下，举荐有特殊才能的、敢于向朝廷直言力谏的人士。

　　夏季，四月丁巳日，立皇子刘骜为皇太子。待诏郑朋推荐太原太守张敞，是先帝名臣，适宜作辅导皇太子的师傅。皇上因而问萧望之，萧望之认为张敞是个能干的官，可治理烦乱之事，但不是大器之材，不能做为太子的师傅。天子派使者征调张敞，想让其任职三辅之一的左冯翊，却逢遇张敞病逝。〔〖按〗京兆尹、左冯翊、右扶风，西汉时本指治理长安京畿地区的三位官员，后指这三位官员管辖的地区：中京兆（长安一代）、左冯翊（东府渭南一代）、右扶风（西府宝鸡一代），即所谓“三辅”之地。〕

　　颁布诏令，赐封萧望之为关内侯爵，加官给事中，允许只在初一、十五两日上朝。

　　关东地区出现饥荒，齐地有人吃人的现象。

　　秋季，七月，己酉日，再次地震。

　　【原文】

　　上复征周堪、刘更生，欲以为谏大夫。弘恭、石显白，皆以为中郎。〔〖胡三省注〗《百官表》：谏大夫，秩比八百石；中郎，秩比六百石：并属光禄勋。〕

　　上器重萧望之不已，欲倚以为相；恭、显及许、史子弟、侍中、诸曹皆侧目于望之等。更生乃使其外亲上变事，〔〖胡三省注〗外亲，谓母党也。〕言“地震殆为恭等，不为三独夫动。〔〖胡三省注〗应劭曰：三独夫，谓萧望之、周堪及向。师古曰：独夫，犹言匹夫也。殆，近也。〕臣愚以为宜退恭、显，以章蔽善之罚，〔〖胡三省注〗師古曰：章，明也。〕进望之等以通贤者之路。如此，则太平之门开，灾异之原塞矣。”书奏，恭、显疑其更生所为，白请考奸诈，辞果服。遂逮更生系狱，免为庶人。

　　【译文】

　　皇上再次征召周堪、刘更生入职，想封他们做谏议大夫。弘恭、石显上奏，都认为应该封为中郎。

　　皇上始终器重萧望之，想封他为丞相以做倚靠；而弘恭、石显及许、史两家子弟、侍中及各部官员，却都对萧望等人抱以轻蔑态度。刘更生于是指使外亲就异变之事上书，称“出现地震仅是因为弘恭等人，而不是因为已被罢免的萧望之、周堪、刘更生三个匹夫而动。愚臣以为应该辞退弘恭、石显，以明示对排斥忠善行为的惩罚，并召用萧望之等人，以畅通忠贤之路。如此，则太平之门打开，灾异的源头就封闭了。”上书奏过，弘恭、石显怀疑是刘更生所为，便启奏皇上追究其中奸诈之举，供辞中果然有招认。于是逮捕刘更生下狱，罢免为平民。

　　【原文】

　　会望之子散骑、中郎伋亦上书讼望之前事，〔〖胡三省注〗散骑、中郎者，本为中郎而加散骑官也。〕事下有司。复奏：“望之前所坐明白，无谮诉者，〔〖胡三省注〗师古曰：言望之自有罪，非人谗谮而诉之也。〕而教子上书，称引亡辜之诗，〔〖胡三省注〗史不载伋书，不知其所称引者何诗。《诗》变雅云：”无罪无辜，谗口嗷嗷。“岂伋所引者即此诗乎？亡，古无字通。〕失大臣体，不敬，请逮捕。”弘恭、石显等知望之素高节，不诎辱，〔〖胡三省注〗诎，与屈同。〕建白：“望之前幸得不坐，复赐爵邑，不悔过服罪，深怀怨望，教子上书，归非于上，〔〖胡三省注〗师古曰：言归恶于天子也。〕自以托师傅，终必不坐。〔〖胡三省注〗师古曰：言恃旧恩，自谓终无罪坐，怀此心。〕非颇屈望之于牢狱，塞其怏怏心，则圣朝无以施恩厚。”上曰：“萧太傅素刚，安肯就吏！”显等曰：“人命至重。〔〖胡三省注〗言人所重者性命也。〕望之所坐，语言薄罪，〔〖胡三省注〗既以语言为薄罪，则不当下吏。孝元于此，不能破恭、显之奸，可谓不明矣。〕必无所忧。”上乃可其奏。

　　冬，十二月，显等封诏以付谒者，敕令召望之手付。因令太常急发执金吾车骑驰围其第。〔〖胡三省注〗太常，掌诸陵县。执金吾，掌徼循京师。萧望之时居杜陵，故令太常发执金吾车骑往围其第以恐胁之，速其自尽也。〕使者至，召望之。望之以问门下生鲁国朱云，云者，好节士，劝望之自裁。〔〖胡三省注〗自裁，犹自杀也。〕于是望之仰天叹曰：“吾尝备位将相，年逾六十矣！老入牢狱，苟求生活，不亦鄙乎？”字谓云曰：“游，〔〖胡三省注〗师古曰：朱云，字游，呼其字。〕趣和药来，〔〖胡三省注〗趣，读曰促。和，户卧翻。〕无久留我死！”竟饮鸠自杀。〔〖胡三省注〗果堕恭、显计中。〕天子闻之惊，拊手曰：“曩固疑其不就牢狱，果然杀吾贤傅！”是时，太官方上昼食，上乃却食，为之涕泣，哀动左右。〔〖胡三省注〗《诗》云：啜其泣矣，何嗟及矣。〕于是，召显等责问；以议不详。〔〖胡三省注〗师古曰：详，审也。〕皆免冠谢，良久然后已。上追念望之不忘，每岁时遣使者祠祭望之冢，终帝之世。〔〖胡三省注〗平曰墓，封曰冢，高曰坟。〕

　　【译文】

　　适逢萧望之的儿子散骑中郎萧伋也上书申诉萧望之以前的冤屈，此事被交给有关部门查办。回报称：“萧望之从前的罪过明明白白，没人诬陷他，而他却指使儿子上书申诉，引用表明自己无辜的诗，有失大臣体统，是对皇帝不敬，请予以逮捕。”弘恭、石显等人知道萧望之素有高傲的气节，不肯屈服受辱，便向皇帝建议说：“萧望之先前侥幸没有治罪，还赏赐了爵位和食禄的城邑，他不悔过认罪，还身怀怨忿，唆使儿子上书，归不是于皇上，自以为托皇帝师傅之名，终究不会坐狱。如果不让萧望之在牢狱中受些委屈，遏制他不满的情绪，那么圣朝就没有办法可以施加恩泽了。”皇上说：“萧太傅为人素来刚烈，怎肯受审于官吏呢？”石显等人说：“人最看重的是生命。萧望之所涉罪过，是语言失敬上的轻罪，必定没有好担忧的。”皇上这才准了他的奏。

　　冬季，十二月，石显等封好了皇上诏书交给传达者，责令他召萧望之出来亲手递付。因而命令掌管各陵县事务的太常紧急派发宫城卫队车驾，疾驰赶去包围萧望之的宅第。使者到，传召萧望之。萧望之因此询问门生鲁国人朱云。朱云是一个重视名节的人，就劝萧望之自杀。当时萧望之仰天长叹说：“我也曾身居将相之位，今已年过六十了！到老竟入了监狱，这样苟且偷生，还不令人难堪吗？”便称呼着朱云的字说：“游，去和药来，让我早点死了吧！”他竟然喝毒酒自杀了。皇上听说后十分震惊，拍手叹气说：“先前我就怀疑他不肯进牢狱，结果害了我的好师傅！”当时，太官刚刚端上午餐，皇上推开饭食，为萧望之哭泣，悲哀之情让左右侍从动容。于是召来石显等人责问，最后以议事不周密之过，他们都脱下帽子谢罪，很长时间才算作罢。汉元帝追思萧望之不能忘怀，每年此时派使者祭祀萧望之的坟墓，直至整个汉元帝时代结束。

　　【原文】

　　臣光曰：甚矣！孝元之为君，易欺而难寤也！夫恭、显之谮诉望之，其邪说诡计，诚有所不能辨也。至于始疑望之不肯就狱，恭、显以为必无忧。已而果自杀，则恭、显之欺亦明矣。在中智之君，孰不感动奋发以底邪臣之罚！〔〖胡三省注〗底，致也。〕孝元则不然。虽涕泣不食以伤望之，而终不能诛恭、显，才得其免冠谢而已。如此，则奸臣安所惩乎！是使恭、显得肆其邪心而无复忌惮者也。

　　是岁，弘恭病死，石显为中书令。

　　【译文】

　　臣司马光认为：太不可思议了！作为君主的汉元帝，这样容易被人欺骗却又难以醒悟！那弘恭、石显用谗言状告萧望之，以他们的邪说和诡计，皇上确实也难以识别。至于皇上最初不放心萧望之不肯坐牢，而弘恭、石显却说肯定不会出问题。后来萧望之果然自杀，则弘恭、石显的欺骗目的也就都看清了。这在具有一般智慧的君主来说，谁不愤然而起，处罚奸邪之臣呢！可汉元帝则不然，虽为萧望之伤心流泪不进食，然而终还是不能诛杀弘恭、石显，才使得他们仅是脱帽子谢罪而已。如此，则奸佞之臣怎能得到惩治呢？这也就是弘恭、石显能够放纵奸邪之心而又无所忌惮的原因了。

　　这一年，弘恭病死，石显做了中书令。

　　【原文】

　　初，武帝灭南越，开置珠厓、儋耳郡，〔〖胡三省注〗事见二十卷武帝元鼎六年。儋，丁甘翻。〕在海中洲上，〔〖胡三省注〗师古曰：居海中之洲也。水中可居者曰洲。〕吏卒皆中国人，多侵陵之。其民亦暴恶，自以阻绝，数犯吏禁，率数年壹反，杀吏。汉辄发兵击定之。二十馀年间，凡六反。〔〖胡三省注〗据《贾捐之传》：自初为郡，至昭帝始元元，二十余年间，凡六反。〕至宣帝时，又再反。〔〖胡三省注〗始元五年，罢儋耳郡并属珠厓。至宣帝神爵三年，珠厓三县反。后七年，甘露元年，九县复反。〕上即位之明年，珠厓山南县反，发兵击之。诸县更叛，连年不定。〔〖胡三省注〗海中洲上，以黎母山为主，环山列置诸县。山南县盖置于黎母之南也。师古曰：更，音工衡翻。〕上博谋于群臣，欲大发军。

　　待诏贾捐之曰：〔〖胡三省注〗捐之时待诏金马门。〕

　　“臣闻尧、舜、禹之圣德，地方不过数千里，西被流沙，东渐于海，朔南暨声教。〔〖胡三省注〗师古曰：此引《禹贡》之辞。渐，入也；一曰浸也。朔，北方也。暨，及也。被，皮义翻。渐，子廉翻。〕言欲与声教则治之，不欲与者不强治也。〔〖胡三省注〗与，读曰豫。〕故君臣歌德，〔〖胡三省注〗师古曰：言皆有德可歌颂。〕含气之物各得其宜。武丁、成王，殷、周之大仁也，然地东不过江、黄，〔〖胡三省注〗杜预曰：江国，在汝南安阳县。黄国，今弋阳县。〕西不过氐、羌，南不过蛮荆，北不过朔方，是以颂声并作，视听之类咸乐其生，越裳氏重九译而献，此非兵革之所能致也。〔〖胡三省注〗晋灼曰：远国使来，因九译言语乃通也。张晏曰：越不著衣裳，慕中国化，遣译来著衣裳，故曰越裳也。师古曰：越裳自是国名，非以袭衣裳始为称号也。王充《论衡》作“越尝”，此则不作衣裳之字明矣。《晋志》曰：吴孙皓置九德郡，即周时越裳氏地。〕

　　“以至于秦，兴兵远攻，贪外虚内而天下溃畔。孝文皇帝偃武行文，当此之时，断狱数百，赋役轻简。孝武皇帝厉兵马以攘四夷，天下断狱万数，赋烦役重，寇贼并起，军旅数发；父战死于前，子斗伤于后；女子乘亭障，孤儿号于道，老母、寡妇饮泣巷哭。〔〖胡三省注〗师古曰：泪流被面以入于口，故言饮泣也。巷哭者，哭于路也。号，户刀翻。〕是皆廓地泰大，征伐不休之故也。今关东民众久困，流离道路。人情莫亲父母，莫乐夫妇；至嫁妻卖子，法不能禁，义不能止，此社稷之忧也。

　　“今陛下不忍悁悁之忿，〔〖胡三省注〗悁，又吉掾翻，忿也，忧也；《诗》：“中心悁悁”。又急躁貌。〕欲驱士众挤之大海之中，〔〖胡三省注〗师古曰：挤，坠也，音子诣翻，又子奚翻；余谓挤，排也，推也。〕快心幽冥之地，非所以救助饥馑，保全元元也。《诗》云：‘蠢尔蛮荆，大邦为雠。’〔〖胡三省注〗师古曰：《诗·小雅·采芑》之诗也。蠢，动貌也。蛮荆，荆州之蛮也。言敢与大国为雠敌也。〕言圣人起则后服。中国衰则先畔，自古而患之，何况乃复其南方万里之蛮乎！〔〖胡三省注〗言珠厓又在蛮荆之南，去京师万里。〕骆越之人，〔〖胡三省注〗南越王尉佗以兵威役属西瓯骆。师古曰：西瓯，即骆越也。言西者，以别东瓯也。余谓今安南之地，古之骆越也。珠厓，盖亦骆越地。宋白曰：高、贵二州，亦古骆越地。〕父子同川而浴，相习以鼻饮，〔〖胡三省注〗范成大曰：今邕管溪洞及沿海喜鼻饮。随贫富，以银、锡、陶器或大瓢盛水，入盐，并山薑汁数滴；器侧有窍，施管如瓶觜，内鼻中，吸水升脑，下入喉。吸水时，含鱼肉鲊一脔，故水得安流入鼻，不与气相激。既饮，必噫气，谓凉脑快膈莫此若。但可饮水，或传为饮酒，非是。〕与禽兽无异，本不足郡县置也。颛颛独居一海之中，〔〖胡三省注〗师古曰：顓，与专同。专专，犹区区也；一曰：圜貌也。〕雾露气湿，多毒草、虫蛇、水土之害；人未见虏，战士自死。又非独珠厓有珠、犀、瑇瑁也。〔〖胡三省注〗海中有珠池。珠母者，蚌也。采珠必蜑丁，皆居海艇中，以大舶环池采珠；以石悬大絙，别以小绳系蜑（丁）腰，没水取珠。气迫则撼绳，绳动，舶人觉，乃绞取，人缘大絙上。然而死于采珠者亦多矣，此我太祖皇帝所以罢刘氏媚川都也。师古曰：犀状如牛，头如猪，而四足类象；黑色；一角当额前，鼻上又有小角。刘欣明《交州记》曰：犀，其毛如豕，蹄有三甲，头如马；有三角，鼻上角短，额上、头上角长。《异物志》曰：角中特有光耀，白理如线，自本达末，则为通天犀。《抱朴子》曰：通天犀有白理如线者，以盛米，鸡即骇矣。其真者，刻为鱼，衔入水，水开三尺。《本草图经》曰：犀，出永昌山谷及益州，今出南海者为上。郭璞《尔雅》注曰：犀三角，一在顶上，一在额上，一在鼻上。鼻上者，即食角，小而不椭。瑇瑁，如龟，其甲相覆而生，若甲然；甲上有斑文。瑇，音代。瑁，音妹。〕弃之不足惜，不击不损威。其民譬犹鱼鳖，何足贪也！

　　“臣窃以往者羌军言之，〔〖胡三省注〗此盖指宣帝神爵元年羌反时。〕暴师曾未一年，兵出不逾千里，费四十馀万万；大司农钱尽，乃以少府禁钱续之。〔〖胡三省注〗《续汉志》：大司农掌诸钱谷金帛、诸货币。边郡诸官请调度者，皆为报给，损多益寡，取相给足。《百官表》：少府，掌山林池泽之税，以给共养。应劭注曰：名曰禁钱，以给私养，自别为藏。少者，小也。故称少府。师古曰：大司农，供军国之用；少府，以养天子也。〕夫一隅为不善，费尚如此，况于劳师远攻，亡士毋功乎？〔〖胡三省注〗毋，与无同。〕求之往古则不合，施之当今又不便，臣愚以为非冠带之国，《禹贡》所及，《春秋》所治，皆可且无以为。〔〖胡三省注〗师古曰：为，犹用也。治，直之翻。〕愿遂弃珠厓，专用恤关东为忧。”

　　上以问丞相、御史。御史大夫陈万年以为当击，丞相于定国以为：“前日兴兵击之连年，护军都尉、校尉及丞凡十一人，还者二人，卒士及转输死者万人以上，费用三万万馀，尚未能尽降。今关东困乏，民难摇动，捐之议是，”上从之。

　　捐之，贾谊曾孙也。

　　【译文】

　　当初，汉武帝征灭南越，设置珠厓郡、儋耳郡，这两个郡都处于南海之洲，〔〖按〗即今海南岛。儋耳郡：汉郡名，治所在儋耳，今广东海南岛儋县西北，辖境约相当于今海南岛西部地区。珠厓郡：治所在今海南省琼山县。〕其官吏士卒都是中原国土之人，常常遭到侵犯和欺凌。那里的民众也很暴力凶恶，自以为与大陆隔绝，多次违犯官吏的禁令，大约几年就反叛一次，杀死官吏。汉朝廷便发兵征剿予以平定。二十多年间，共有六次反叛。到了宣帝年间，又一次反叛。今元帝即位的第二年，珠厓山南县出现反叛，朝廷发兵征剿。然而各县轮番反叛，连年都不得安定。皇上博采众臣之谋策，欲大规模发兵。

　　金马门待诏人员贾捐之奏道：

　　“臣听说过尧、舜、禹的圣德，虽所辖之地不过数千里，却惠及西域流沙，影响到东海之滨，南北皆领受其训导和教化。言称若想接受训导和教化的地方，便去治理它；若不想接受训导和教化的，便不强制去治理。故而君臣之德被歌颂，凡有气息生命之物都各有所安。武丁、成王是殷朝和周朝最仁德的君主了，然而其领地东不过江国、黄国，西不过氐人、羌人区域，南不过蛮荆，北不过朔方，能做到颂扬之声四起，能视听的物类都快乐地生活着，还有越裳氏派使者经过九种语言翻译前来献贡，这都不是靠军事武力所能达到的。〔〖按〗越裳，又作越尝。古地名，并非指越人着衣而来。〕

　　“当到了秦朝时，大兴兵马向远攻伐，贪得于外，却空虚于内，以致天下叛乱。到汉文帝时，罢武兴文，这一时期审理的牢狱案件不过数百起，税赋徭役也轻薄而简单。到汉武帝时，强化兵马实力以抵御四方外夷，天下牢狱案件数以万计，税赋徭役繁重，兵匪之乱接连而起，军队多次派发；作为父亲的战死于前，儿子又斗伤于后，女子也去参与防守关隘；孤儿嚎哭于路上，老母、寡妇哭泣于街里巷间。这些都是扩充土地过大、征伐不休的缘故。如今关东地区民众久陷于贫困，颠沛流离于途中。论人情关系，至亲莫过于父母，喜爱莫过于夫妇，然而竟至于转嫁妻子、卖掉儿女，法律和道义却又无力禁止，这是国家社稷之忧患啊。

　　“今天陛下忍不了这耿耿于怀的忿懑，想驱使众士兵拥入大海之中，图痛快于那一处幽暗荒蛮之地，这并不能救助饥饿、保全黎民百姓。《诗经》上说：‘蠢动的蛮荆之人，竟敢与大国为敌。’有道是圣人出，然后得以服顺。当中原之国衰败之时则蛮荆之地先行叛乱，自古以来就有此祸患，又何况是处于蛮荆南面万里之外的蛮荒之地呢！骆越地区的人，父子在同一条河中洗浴，互相习惯用鼻子饮水，与禽兽没什么不同，本来就不值得在那里设置郡县。区区独居一海之中，雾露之气潮湿，多有毒草、虫蛇、水土之害；还未等见到虏寇，派去的战士就先自死亡。又非仅仅是珠厓地区出产珍珠、犀牛、玳瑁，舍弃它不值得惋惜，不攻剿它无损于国威。那里的民众如同鱼鳖之群，有什么可贪恋的呢？

　　“臣我拿过去宣帝时征剿羌人叛乱一事来说，出师不到一年，兵行不超过千里，便耗资四十余万万铜钱；大司农掌管的钱用光了，便以少府掌管的宫钱来接济。一个角落之地出现问题，费用尚且如此，又何况明知损兵折将而无功的劳师远征南越呢？参照古人的做法则不符，施行当今的做法又不便利。依臣的愚见以为，不是穿戴上文明的城国，不是《尚书·禹贡》中划分过的区域，不是《春秋》一书中涉及治理的地方，都可管可不管。希望就此放弃珠厓郡那个地方，专心忧虑一下抚恤关东之事吧。”〔〖按〗《通典·州郡·古南越》载：“自岭而南，当唐虞三代，为蛮夷之国，是百越之地，亦谓之南越。古谓之雕题，非《禹贡》九州之域，又非《周礼》职方之限。”不过太古时如此，而汉既已收为疆土，岂可轻言弃之。无能之君，避事之臣，值灾凶之岁，是有此议。〕

　　皇上就此事征求丞相、御史意见。御史大夫陈万年认为应当征讨，丞相于定国则以为：“以前连年发兵征讨珠厓郡的叛乱，领兵的护军都尉、校尉及副职共十一人，仅回来两人，士兵及转运粮草者死了万余人，耗资三万万多铜钱，尚还没能使叛乱者全部投降。现今关东地区困乏，百姓灾难不定，贾捐之的议论是对的。”皇上就听从了建议。

　　贾捐之，贾谊的曾孙。

　　【原文】

　　汉孝元皇帝　初元三年（乙亥，公元前46年）

　　春，诏曰：“珠厓虏杀吏民，背畔为逆。今廷议者或言可击，或言可守，或欲弃之，其指各殊。朕日夜惟思议者之言，羞威不行，则欲诛之；狐疑辟难，则守屯田；〔〖胡三省注〗师古曰：辟，读曰避；下同。欲屯田与之相守，以待其敝。〕通于时变，则忧万民。夫万民之饥饿与远蛮之不讨，危孰大焉？且宗庙之祭，凶年不备，〔〖胡三省注〗王制：冢宰制国用，视年之丰耗，祭用数之仂。郑氏曰：算今年一岁经用之数，用其什一。夫以凶年之入，制经用之什一以供祭，则宗庙之礼宜有不备者矣。〕况乎辟不嫌之辱哉！〔〖胡三省注〗"嫌"，当读作"慊"。慊之为言厌也，意自足也。〕今关东大困，仓库空虚，无以相赡，又以动兵，非特劳民，凶年随之。其罢珠厓郡，民有慕义欲内属，便处之；〔〖胡三省注〗师古曰：欲有来入内郡者，所至之处即安置之。余谓便处者，各随其所便而处之也。处，昌吕翻。〕不欲，勿强。”

　　夏，四月，乙未晦，茂陵白鹤馆灾。赦天下。

　　夏，旱。

　　立长沙炀王弟宗为王。〔〖胡三省注〗长沙炀王旦，定王发之玄孙，初元元年薨，无后；今立其弟绍封。郑氏曰：炀，音供养之养。谥法：好内远礼曰炀，去礼远众曰炀。〕

　　长信少府贡禹上言：“诸离宫及长乐宫卫，可减其太半以宽繇役。”〔〖胡三省注〗繇，读曰傜。〕六月，诏曰：“朕惟烝庶之饥寒，〔〖胡三省注〗烝，众也。〕远离父母妻子，劳于非业之作，〔〖胡三省注〗师古曰：不急之事，故云非业也。〕卫于不居之宫，恐非所以佐阴阳之道也。其罢甘泉、建章宫卫，令就农。百官各省费，〔〖胡三省注〗师古曰：费用之物，务减省。〕条奏，毋有所讳。”

　　是岁，上复擢周堪为光禄勋，堪弟子张猛为光禄大夫、给事中，大见信任。〔〖胡三省注〗猛，张骞孙也。〕

　　【译文】

　　汉元帝初元三年（乙亥，公元前46年）

　　春季，汉元帝颁诏说：“珠厓地区出现掳杀官民、叛逆作乱之事。现今朝廷议事大臣或说可征伐的，或说可以镇守的，或说可以放弃的，意见不一。朕日夜深思大臣们的意见。若羞耻于国威不立，则欲出兵征剿南越；若犹疑难定、回避艰难，则欲驻守边防进行屯垦；若通考于时势变故，则应忧虑于万民。这万民饥饿一事与远方蛮人未得以征讨一事，哪个危害更大呢？宗庙祭祀若逢遇凶灾之年尚且讲究回避而不宜备办，何况回避那不足以说明“国威不立”之耻辱呢！如今关东地区遭遇重大灾困，仓库空虚，无法给予赒济，而又要动兵，不单单是劳苦了百姓，还会有凶灾之年会跟随而来。就此废除珠厓郡，若那里的民众有向往大义的，想归属内地，便安排好他们；若不想来，便不要强迫。”

　　夏季，四月，乙末晦，茂陵白鹤馆发生火灾。大赦天下。

　　夏季，干旱。

　　封长沙炀王刘旦的兄弟刘宗为王。〔〖按〗刘旦，刘建德之子，前49年～前47年在位，位二年，谥炀，无子。刘旦无子，弟刘宗继承长沙王爵，前46年～前42年在位，位五年，谥孝。〕

　　长信少府贡禹上书道：“各离宫及长乐宫的守卫，可裁掉大半，以便减轻民众的徭役负担。”六月，皇上下诏：“朕考虑到民众的饥寒之苦，他们远离父母妻子，从事于并非家业的劳作，守卫于没人居住的宫殿，恐怕这不是有益于阴阳平和之道。就此撤除甘泉、建章宫的守卫，使他们得以务农。所有官员需减省的各种费用，按条款奏来，不要有所忌讳。”

　　这一年，皇上又提拔周堪为光禄勋。提拔周堪的弟子张猛（张骞之孙）为光禄大夫，加官给事中，可见大受信任。

　　【原文】

　　汉孝元皇帝　初元四年（丙子　公元前45年）

　　春，正月，上行幸甘泉，郊泰畤。〔〖胡三省注〗畤，音止；下同。〕三月，行幸河东，祠后土；赦汾阴徒。〔〖胡三省注〗徒，有罪居作者。〕

　　汉孝元皇帝　初元五年（丁丑　公元前44年）

　　春，正月，以周子南君为周承休侯。〔〖胡三省注〗文颖曰：姓姬，名延；其祖父姬嘉，本周后，武帝元鼎四年封为周子南君，奉周祀。师古曰：承休侯国，在颍川郡。〕三月，上行幸雍，祠五畤。

　　夏，四月，有星孛于参。〔〖胡三省注〗孛，蒲内翻。《天文志》：参为白虎，三星直者是为衡石；下有三星锐，曰罚，为斩艾事，其外四星，左右肩、股也。参，所今翻。〕

　　上用诸儒贡禹等之言，诏太官毋日杀，〔〖胡三省注〗师古曰：不得日日宰杀。〕所具各减半。〔〖胡三省注〗师古曰：食具也。〕乘舆秣马，无乏正事而已。〔〖胡三省注〗师古曰：秣，养马以粟秣食之也。正事，谓驾供祭祀、蒐狩之事，非游田者也。乘，绳证翻。秣，音末。〕罢角抵、上林宫馆希御幸者、〔〖胡三省注〗角抵，见二十一卷武帝元封三年。〖按〗角抵：摔跤、相扑。〕齐三服官、北假田官、〔〖胡三省注〗李斐曰：主假赁见官田与民，收其假税也，故置田农之官。晋灼曰：《匈奴传》秦始皇渡河，据阳山、北假中。《王莽传》：五原、北假膏壤殖谷。北假，地名。师古曰：晋说是也。郦道元曰：自高阙以东，夹山带河，阳山以西，皆北假也。〕盐铁官、常平仓。〔〖胡三省注〗武帝置“盐铁官”。宣帝置“常平仓”。〕博士弟子毋置员，以广学者。〔〖胡三省注〗武帝为博士官置弟子五十人。昭帝增弟子员满百人。宣帝末，增倍之。令不限员数以广学者。后数年，以用度不足，更为设员千人。〕令民有能通一经者，皆复。〔〖胡三省注〗复，方目翻。〖按〗复，此指免除徭役赋税。如复除、复租、复免。晁错《论贵粟疏》：“民有车骑马一匹者，复卒三人。”复卒，指免除兵役。〕省刑罚七十馀事。

　　陈万年卒。

　　六月，辛酉，长信少府贡禹为御史大夫。禹前后言得失书数十上，上嘉其质直，多采用之。

　　【译文】

　　汉元帝初元四年（丙子，公元前45年）

　　春季，正月，汉元帝驾临甘泉，郊祭天神于泰畤。三月，御驾光临河东，春祭于后土祠，释放汾阴的囚犯。

　　汉元帝初元五年（丙子，公元前44年）

　　春季，正月，以周子南君姬延为周承休侯。三月，汉元帝驾临雍州，分别到五畤原进行祭祀。

　　夏季，四月，有异星出现于参宿之位。

　　汉元帝采用贡禹等各位儒家学者的建议，下诏告知掌管宫廷膳食的太官不要天天杀生，所呈献的肉类物食各减一半。车辆及喂养的马，以足够办正事为限。取消角抵（摔跤、相扑。）、上林苑准备招待天子的宫馆、齐三服官、北假田官、盐铁官、“常平仓”官。博士弟子不设置定员，以便广招学者。告示民众，有能通解一部经卷者，尽免其赋税徭役。减掉刑罚律条七十多款。

　　御史大夫陈万年去世。

　　六月，辛酉日，长信少府贡禹任御史大夫。贡禹为谈“得失”之理，前后奏书数十本；皇上赞许贡禹本质耿直，多予以采用。

　　【原文】

　　匈奴郅支单于自以道远，又怨汉拥护呼韩邪而不助己，困辱汉使者江乃始等；遣使奉献，因求侍子。〔〖胡三省注〗郅支遣子入侍，见上卷宣帝甘露元年。〕汉议遣卫司马谷吉送之。〔〖胡三省注〗谷，姓也。〕御史大夫贡禹、博士东海匡衡以为：“郅支单于鄉化未醇，〔〖胡三省注〗师古曰：不杂曰醇。醇，壹也，厚也。鄉，读曰嚮（向）；下同。〖按〗古文中以“鄉”通假“嚮”时，不可简写作“乡”。嚮，今简化作“向”。〕所在绝远，宜令使者送其子至塞而还。”吉上书言：“中国与夷狄有羁縻不绝之义，今既养全其子十年，德泽甚厚；空绝而不送，近从塞还，示弃捐不畜，使无鄉从之心，〔〖胡三省注〗师古曰：鄉从，谓向化而从命也。〕弃前恩，立后怨，不便。议者见前江乃始无应敌之数，智勇俱困，以致耻辱，即豫为臣忧。臣幸得建强汉之节，承明圣之诏，宣谕厚恩，不宜敢桀。〔〖胡三省注〗师古曰：言郅支畏威，当不敢桀猾也。〕若怀禽兽心，加无道于臣，则单于长婴大罪，〔〖胡三省注〗师古曰：婴，犹带也。〕必遁逃远舍，〔〖胡三省注〗师古曰：舍，止也。〕不敢近边。没一使以安百姓，国之计，臣之愿也。愿送至庭。”〔〖胡三省注〗郅支单于庭也。〕上许焉。既到，郅支单于怒，竟杀吉等；〔〖胡三省注〗《考异》曰：《陈汤传》“初元四年，郅支求侍子。”元《帝纪》：“五年，谷吉使匈奴，不还。”汤传又云：“御史大夫贡禹议吉不可遣。”按禹今年六月始为御史大夫，或者郅支以明年求侍子，而吉以五年使匈奴也！”〕自知负汉，又闻呼韩邪益强，恐见袭击，欲远去。

　　会康居王数为乌孙所困，与诸翕侯计，〔〖按〗翕侯：汉时乌孙、月氏、康居等部首领的官称，仅次于王。〕以为：“匈奴大国，乌孙素服属之。今郅支单于困阨在外，可迎置东边，使合兵取乌孙而立之，〔〖胡三省注〗师古曰：言与郅支并力共灭乌孙，以其地立郅支，令居之也。〕长无匈奴忧矣。”即使使到坚昆，通语郅支。〔〖胡三省注〗宣帝黄龙元年，郅支都坚昆。〕郅支素恐，又怨乌孙，〔〖胡三省注〗怨乌孙事亦见上卷黄龙元年。〕闻康居计，大说，〔〖胡三省注〗说，读曰悦。〕遂与相结，引兵而西。郅支人众中寒道死，馀财三千人。〔〖胡三省注〗师古曰：中寒，伤于寒也。道死，死于道上也。中，竹仲翻。财，与才同。〕到康居，康居王以女妻郅支，郅支亦以女予康居王，〔〖胡三省注〗妻，七细翻。予，读曰与。〕康居甚尊敬郅支，欲倚其威以胁诸国。郅支数借兵击乌孙，深入至赤谷城，杀略民人，敺畜产去。〔〖胡三省注〗师古曰：敺，与驱同。〕乌孙不敢追。西边空虚不居者五千里。〔〖胡三省注〗《西域传》：乌孙国，治赤谷城，西至康居蕃地五千里。若云空虚者五千里，则自赤谷以西皆不居矣。此已抵其国都，不得云西边也。《陈汤传》作“且千里”，当从之。〕

　　冬，十二月，丁未，贡禹卒。丁巳，长信少府薛广德为御史大夫。

　　【译文】

　　匈奴郅支单于自以为所处遥远，又怨恨汉朝拥护韩邪而不帮助自己，因而羁留了汉朝使者江乃始等人并予以侮辱，并派遣使者带上礼物，向汉朝廷索回自己入朝陪侍的儿子。汉朝廷商议派遣卫司马谷吉去送郅支单于的儿子。御史大夫贡禹及博士东海人匡衡认为：“郅支单于归附朝廷教化之心尚还不纯，所在之地极远，应该命令使者把他儿子送到边境塞口便返回。”卫司马谷吉上书道：“中原之国与边远族群，有牵扯不断的恩义。今已培养造就郅支单于的儿子十年，给予的恩德很厚，若到了空阔绝远之地而不送，使者就近于边塞处返回，即表示丢弃，不再爱护，会使他们失去归向我朝之心，抛弃前面的恩义，积下后来的怨恨，这是不妥当的。议事的大臣们看到之前的使者江乃始没有应付敌人的心计，智慧和勇气都不足，以致遭受耻辱，因而事先替臣担忧。臣有幸得以执持强大的汉朝廷符节，秉承圣明之主的诏令，去宣示深厚的皇恩，他不应敢做暴虐之事。如果他怀有禽兽之心，对臣施加不人道之举，那么单于就长期背负大罪，必定远逃别处，不敢靠近边境。失去一个使臣而能让百姓安定，这正是国家的大计、臣子的愿望。我愿送到郅支单于的朝廷。”皇上答应了他。谷吉到达之后，郅支单于却发了怒，竟然杀了谷吉等使者。郅支单于自知有负汉朝，又听说呼韩邪更加强盛，恐怕遇到袭击，便想远逃它处。

　　正值康居国多次被乌孙国所困扰，康居王与诸位翕侯合计，认为：“匈奴是大国，乌孙一向服从它的管辖。如今郅支单于困阻在外，可把他迎接到东部边境给予安置，使能合兵攻取乌孙并扶立郅支占据那里，便永久没有匈奴的忧患了。”于是立即派使者到坚昆，通话给郅支。郅支本来在担惊受怕，又怨恨乌孙国，闻听康居王之计大喜，遂同意与康居王相联结，于是引兵西进。郅支人众因中了风寒多死于途中，所剩下的才三千人。到达康居后，康居王将女儿给了郅支作妻，郅支也将女儿给了康居王。康居王非常尊敬郅支，想倚靠他的威慑力来胁迫周边各国。郅支多次借兵攻击乌孙国，深入到赤谷城，杀掠百姓，驱赶牲畜而去。乌孙国不敢追击，造成西部无人烟地区达五千里。

　　冬季，十二月，丁未日，贡禹去世。丁巳日，封长信少府薛广德为御史大夫。

　　【原文】

　　汉孝元皇帝　永光元年（戊寅　公元前43年）

　　春，正月，上行幸甘泉，郊泰畤。礼毕，因留射猎。薛广德上书曰：“窃见关东困极，人民流离。陛下日撞亡秦之钟，听郑、卫之乐，臣诚悼之。今士卒暴露，从官劳倦，〔〖胡三省注〗应劭曰：从官，谓宦者及虎贲、羽林、太医、太官是也。师古曰：从官，亲近天子，常侍从者，皆是也。〕愿陛下亟反宫，思与百姓同忧乐，天下幸甚！”上即日还。

　　二月，诏丞相、御史：“举质朴、敦厚、逊让、有行者，光禄岁以此科第郎、从官。”〔〖胡三省注〗师古曰：始令丞相、御史举此四科人而擢用之。而见在郎及从官，又令光禄每岁依此科考校，定其第高下，用知其人贤否也。〖按〗郎官：议郎、中郎、侍郎、郎中等官员的统称。从官：君王的侍从﹑近臣。〕

　　三月，赦天下。

　　雨雪、陨霜，杀桑。

　　秋，上酎祭宗庙，出便门，〔〖胡三省注〗师古曰：便门，长安城南面西头第一门。酎，直又翻。〕欲御楼船。薛广德当乘舆车，免冠顿首曰：“宜从桥。”诏曰：“大夫冠。”〔〖胡三省注〗乘，绳证翻。《说文》：冠，絭也，所以絭发。弁，冕之总名也。〕广德曰：“陛下不听臣，臣自刎，以血汙车轮，陛下不得入庙矣！”〔〖胡三省注〗师古曰：言不以理，终不得立庙也。一曰：以见死伤，犯于斋洁，不得入庙祠也。原父曰：一说是也。时上欲入庙。〖按〗汙，同污。〕上不说。先敺光禄大夫张猛进曰：〔〖胡三省注〗师古曰：先驱，导乘舆也。说，读曰悦。敺，读曰驱。〕“臣闻主圣臣直。乘船危，就桥安，圣主不乘危。御史大夫言可听。”上曰：“晓人不当如是邪！”〔〖胡三省注〗师古曰：谓谏争之言当如猛之详善也。〕乃从桥。

　　【译文】

　　汉元帝永光元年（戊寅　公元前43年）

　　春季，正月，皇上驾临甘泉，郊祭天神于泰畤坛。祭礼完毕，顺便留下来射猎。御史大夫薛广德上书道：“在下知道关东地区极度贫困，人民流离失所。陛下您却每天敲击亡秦的编钟，欣赏着过去郑国、卫国的靡靡之音，臣我实在为此感到哀痛。如今护驾的士卒曝露于风寒中，随从的官员疲劳不堪，希望陛下速返皇宫，想一些与百姓甘苦与共的事，则天下大幸！”皇上当日返还。

　　二月，诏令丞相、御史：“举荐质朴、敦厚、谦逊有品行的人，光禄每年按此内容分科考核录取郎官、从官。”（郎官：议郎、中郎、侍郎、郎中等官员的统称。从官：君王的侍从﹑近臣。）

　　三月，大赦天下。

　　本月雨雪交加，降严霜，冻毁桑田。

　　这年秋天，皇帝用醇酒祭祀宗庙，从便门出来后，准备换乘楼船过河。御史大夫薛广德拦住车马，摘帽叩首向皇上谏说：“陛下应从桥上过河。”皇上说：“大夫戴好头冠。”广德坚持道：“陛下若不听臣劝告，臣就自刎，以血玷污车轮，陛下就不能进入宗庙了！”皇上沉下脸来。这时走在前面开道的光禄大夫张猛进言说：“臣听说，主上圣明，臣下才敢直谏。乘船危险，过桥安全，圣明之君不会选择危险。御史大夫的建议是可听的。”皇上说：“劝告人，就不能学学张猛吗！”于是从桥上而过。

　　【原文】

　　九月，陨霜杀稼，天下大饥。丞相于定国，大司马、车骑将军史高，御史大夫薛广德，俱以灾异乞骸骨。赐安车驷马、黄金六十斤，罢。太子太傅韦玄成为御史大夫。〔〖胡三省注〗《考异》曰：《百官表》“七月，癸未，大司马高免。辛亥，韦玄成为御史大夫。十一月，戊寅，丞相定国免。”荀纪：“七月，己未，高免。”《薛广德传》：“酎祭后月余，以岁恶民流，乞骸骨，罢。广德为御史大夫，凡十月，免。”月日参差，未知孰是，故皆没不书。〕广德归，县其安车，以传示子孙为荣。〔〖胡三省注〗师古曰：县其所赐安车，以示荣幸也。致仕县车，盖亦古法。韦孟诗：“县车之义，以洎小臣，”是也。贡父曰：致仕县车，言休息不出也。故韦孟及薛广德自县其安车也。县，读曰悬。〖按〗“乞骸骨”，为大臣向朝廷辞职时特用谦词，意为乞讨自己这把老骨头归回故乡。安车：坐乘之车。〕

　　帝之为太子也，从太中大夫孔霸受《尚书》。及即位，赐霸爵关内侯，号褒成君，〔〖胡三省注〗如淳曰：为帝师，教令成就，故曰褒成君。〕给事中。上欲致霸相位，霸为人谦退，不好权势，常称“爵位泰过，何德以堪之！”御史大夫屡缺，上辄欲用霸；霸让位，自陈至于再三。上深知其至诚，乃弗用，以是敬之，赏赐甚厚。

　　戊子，侍中、卫尉王接为大司马、车骑将军。〔〖胡三省注〗接，平昌侯王无故之子。〕

　　【译文】

　　九月，降下严霜冻毁庄稼，天下出现大饥荒。丞相于定国，大司马、车骑将军史高，御史大夫薛广德，俱因为灾异的发生而引咎辞职，请求告老还乡。皇上赏赐安车、驷马、黄金六十斤，同意罢职。太子太傅韦玄成被封为御史大夫。薛广德归乡后，把皇上赏赐的安车悬挂起来，用以做为荣誉传示子孙。

　　皇上为太子时，跟随太中大夫孔霸受教《尚书》。即位后，赏赐孔霸为关内侯爵位，号“褒成君”，加官为给事中。皇上想让老师孔霸坐到丞相位置。孔霸为人谦让，不喜好权势，经常说“赏赐侯爵之位太过头了，我有什么德能来承受啊！”御史大夫常有空缺，皇上则想任用孔霸；孔霸辞让这个位置，且自己请求再三。皇上深知他的至诚之心，便不再任用，并因此而敬佩他，赏赐甚为丰厚。

　　戊子日，任命侍中、卫尉王接担任大司马，兼车骑将军。〔〖按〗王接：宣帝外祖母的儿子平昌侯王无故的儿子。〕

　　【原文】

　　石显惮周堪、张猛等，数谮毁之。

　　刘更生惧其倾危，上书曰：

　　“臣闻舜命九官，〔〖胡三省注〗师古曰：尚书，禹作司空，弃后稷，契司徒，皋陶作士，垂共工，益朕虞，伯夷秩宗，夔典乐，龙纳言，凡九官也。〕济济相让，和之至也。众臣和于朝则万物和于野，故《箫韶》九成，凤皇来仪。〔〖胡三省注〗师古曰：韶，舜乐名。举箫管之属，示其备也。于韶乐九奏，则凤皇见其容仪，言感至和也。〕至周幽、厉之际，〔〖胡三省注〗师古曰：厉王，夷王之子。厉王生宣王；宣王生幽王。〕朝廷不和，转相非怨，则日月薄食，水泉沸腾，山谷易处，〔〖胡三省注〗师古曰：薄，迫也；谓被掩迫也。沸，涌出也。腾，乘也。言百川沸涌而相乘陵，山顶隆高而尽崩坏，陵谷易处。〖按〗薄，迫近。薄食，相迫近而食。〕霜降失节。〔〖胡三省注〗谓正月繁霜也。正月，夏之四月，正阳之月也。〕由此观之，和气致祥，乖气致异，祥多者其国安，异众者其国危。天地之常经，古今之通义也。

　　“今陛下开三代之业，招文学之士，优游宽容，使得并进。今贤不肖浑殽，〔〖胡三省注〗师古曰：言杂乱也。浑，音胡本翻。〕白黑不分，邪正杂糅，〔〖胡三省注〗师古曰：糅，和也，音汝救翻。〕忠谗并进。章交公车，人满北军。〔〖胡三省注〗如淳曰：《汉仪注》，中垒校尉，主北军垒门内。尉一人，主上书者狱。上章于公车，有不如法者，以付北军尉；北军尉以法治之。杨恽上书，遂幽北阙。北阙，公车所在。〕朝臣舛午，胶戾乖剌，〔〖胡三省注〗师古曰：言志意不和，各相违背。午，音五故翻。剌，音来曷翻。〕更相谗诉，转相是非，所以营惑耳目，感移心意，不可胜载。〔〖胡三省注〗师古曰：言其诬罔天子也。营，谓回绕之。〖按〗耳目者，视听也；心意者，意志也。感，通“撼”。〕分曹为党，〔〖胡三省注〗师古曰：曹，辈也。〕往往群朋将同心以陷正臣。正臣进者，治之表也；正臣陷者，乱之机也。乘治乱之机，未知孰任，而灾异数见，此臣所以寒心者也。初元以来六年矣，按春秋六年之中，灾异未有稠如今者也。〔〖胡三省注〗师古曰：稠，多也。〕原其所以然者，由谗邪并进也；谗邪之所以并进者，由上多疑心。

　　“既已用贤人而行善政，如或谮之，则贤人退而善政还矣。〔〖胡三省注〗师古曰：还谓收还也。〕夫执狐疑之心者，来谗贼之口；持不断之意者，开群枉之门。谗邪进则众贤退，群枉盛则正士消。故《易》有‘否’‘泰’，〔〖胡三省注〗师古曰：否，音皮鄙翻。〕小人道长，君子道消，则政日乱；君子道长，小人道消，则政日治。

　　“昔者鲧、共工、驩兜与舜、禹杂处尧朝，〔〖胡三省注〗师古曰：鲧，崇伯之名，即梼杌也。共工，少皞氏之后，即穷奇也。驩兜，帝鸿氏之后，即浑敦也。鲧，音工本翻。共，音恭。驩，音火官翻。处，昌吕翻。〕周公与管、蔡并居周位。当是时，迭进相毁，〔〖胡三省注〗师古曰：迭，互也，音大结翻。〖按〗迭进：轮番进言、秉奏。〕流言相谤，岂可胜道哉！帝尧、成王能贤舜、禹、周公而消共工、管、蔡，故以大治，荣华至今。孔子与季、孟偕仕于鲁，〔〖胡三省注〗师古曰：季、孟，谓季孙、孟孙，皆桓公之后，代执国权而卑公室。余谓季孙、孟孙，季、孟之通称。与孔子偕仕者，季孙斯、孟孙何忌也。〕李斯与叔孙俱宦于秦，〔〖胡三省注〗师古曰：叔孙者，叔孙通也。〕定公、始皇贤季、孟、李斯而消孔子、叔孙，故以大乱，污辱至今。故治乱荣辱之端，在所信任；信任既贤，在于坚固而不移。《诗》云‘我心匪石，不可转也’，〔〖胡三省注〗师古曰：此《邶·柏舟》之诗也。言石性虽坚，尚可移转；己志须确，执德不倾，过于石也。〕言守善笃也。《易》曰‘涣汗其大号’，〔〖胡三省注〗师古曰：此《易·涣卦》九五爻辞也。言王者涣然大发号令，如汗之出也。〕言号令如汗，汗出而不反者也。今出善令未能踰时而反，〔〖胡三省注〗师古曰：踰时，三月也。〕是反汗也；用贤未能三旬而退，〔〖按〗三旬，此指三十日。〕是转石也。《论语》曰‘见不善如探汤。’〔〖胡三省注〗师古曰：《论语》载孔子之言。探汤，言其除难无所避也。探，吐南翻。〕今二府奏佞讇不当在位，〔〖胡三省注〗师古曰：讇，古谄字。〕历年而不去。故出令则如反汗，用贤则如转石，去佞则如拨山，如此，望阴阳之调，不亦难乎！

　　“是以群小窥见间隙，缘饰文字，巧言丑诋，〔〖胡三省注〗师古曰：诋，毁也，辱也。〕流言、飞文哗于民间。〔〖胡三省注〗放言于外以诬人，曰流言。孔颖达曰：流，谓水流。造作虚语，使人传之，如水之流然，故谓之流言。为飞书以诋毁，若今之匿名书，曰飞文。师古曰：哗，讙也，音火瓜翻。〕故《诗》云‘忧心悄悄，愠于群小，’〔〖胡三省注〗师古曰：《邶·柏舟》言仁人不遇之诗。悄悄，忧貌。慍，怒也。悄，音千小翻。慍，于问翻。〕小人成群，诚足愠也。昔孔子与颜渊、子贡更相称誉，不为朋党；〔〖胡三省注〗师古曰：事具见《论语》。〖按〗更相：交相也，彼此相互而为也。更，音庚。〕禹、稷与皋陶传相汲引，不为比周。〔〖胡三省注〗师古曰：事见《尚书》。传，递也。〕何则？忠于为国，无邪心也。今佞邪与贤臣并交戟之内，〔〖胡三省注〗师古曰：交戟，谓宿卫者。〖按〗交戟，谓卫士交戟而侍立的朝廷。〕合党共谋，违善依恶；歙歙訿訿，〔〖胡三省注〗《诗·小旻》：“歙歙訿訿。”毛氏注曰：潝潝然患其上，訿訿然思不称于上。《尔雅》云：潝潝訿訿，莫供职也。韩《诗》云：不善之貌。歙，与潝同，许急翻。訿，音紫。〕数设危险之言，欲以倾移主上。如忽然用之，此天地之所以先戒，灾异之所以重至者也。自古明圣未有无诛而治者也，故舜有四放之罚，〔〖胡三省注〗师古曰：谓舜流共工于幽州，放驩兜于崇山，窜三曲于三危，殛鲧于羽山。〕孔子有两观之诛，〔〖胡三省注〗应劭曰：少正卯，奸人之雄，故孔子为司寇七日，诛之于两观之下。师古曰：两观，谓阙也。观，古玩翻。〕然后圣化可得而行也。今以陛下明知，〔〖胡三省注〗知，读曰智。〕诚深思天地之心，览“否”“泰”之卦，历周、唐之所进以为法，原秦、鲁之所消以为戒。〔〖胡三省注〗师古曰：历，谓历观之。原，谓思其本也。周，成王；唐，唐尧。〕考祥应之福，省灾异之祸，以揆当世之变。放远佞邪之党，坏散险诐之聚，〔〖胡三省注〗师古曰：揆，度也。险言，曰诐。诐，彼义翻。〕杜闭群枉之门，方开众正之路。决断狐疑，分别犹豫，使是非炳然可知，则百异消灭而众祥并至。太平之基，万世之利也！”

　　显见其书，愈与许、史比而怨更生等。〔〖胡三省注〗比，毗至翻，下同。〖按〗：比，音毗，亲和，结党。〕

　　【译文】

　　中书令石显畏惧周堪、张猛等人，多次用谗言毁谤他们。

　　刘更生惧怕他的险诈，上书道：

　　“臣听说舜时任命的九官，他们都相互谦让，非常和睦。众臣和睦于朝廷，则万物和谐于民间乡野。故而奏《箫韶》之乐九章，凤凰翩翩也来一展容仪。到了周幽王、周厉王之代，朝廷不和，互相非难结怨，以至于出现日月欺近相食，地下泉水沸腾翻涌，高山峡谷迁变易位，寒霜违背季节而降。由此来看，和气能带来祥瑞之象，戾气会招致怪异之象。祥瑞之象多，这个国家就安稳；怪异之象频繁，这个国家就有危难。这是天地运行的常规，是贯通古今的义理。

　　“今天陛下开启三代之祖业，征召懂得文治之道的人士，温和而宽容相待，使得他们齐来进言。而今是贤人和品行不端者混淆，黑白不分，正邪混杂难辨，忠言与谗言并奏。奏章呈交到公车之署，结果被羁押的人充满北军。朝臣志向不和，歪曲违逆，互相诬告，彼此间搬弄是非，如此迷惑视听、动摇皇上意志之事，不可胜数。拉帮结党，往往是亲朋同伙串通一气去陷害正直之臣。正直之臣得势，是国家得以治理的表现；正直之臣被陷害，是国家陷入动乱的契机。值此治理与动乱关头，未知谁可堪任，而灾异之事频现，这正是臣所为之寒心的。初元（陛下登基）以来，已六年了，按《春秋》史载的六年之内，灾异之事未有如今这般密集的出现过啊。之所以如此，是由于玩弄是非的奸邪之臣都得势了；玩弄是非的奸邪之臣之所以得势，是由于皇上多有疑心。

　　“既然已纳用贤臣来施行善政，若毁谤他们，则贤臣们退去而善政也就不在了。怀有多疑之心，招来玩弄是非的贼人口舌；没有果断的主意，便开了一群枉法之徒的方便之门。玩弄是非的奸邪之臣当势，则众贤良之臣隐退；一群枉法之徒兴扬，则正直之士就没了。所以，《易经》中有‘否’‘泰’之说，小人之势长，君子之势消，则国政一天比一天乱下去；君子之势长，小人之势消，则国政一天比一天好起来。

　　“古人鲧、共工、驩兜与舜、禹，混杂处于尧帝之朝；周公与管叔、蔡叔，并居于周朝官位。在那个时候，他们轮番秉奏互相诋毁，以流言互相诽谤，这些怎能说得过来啊！帝尧、周成王能任贤于舜、禹、周公，而灭掉共工、管叔与蔡叔，因此国家得到全面治理，其荣誉被传扬至今。孔子和季孙氏、孟孙氏同在鲁国做官，李斯和叔孙通都在秦国做官；鲁定公、秦始皇任用季孙氏、孟孙氏、李斯，而排斥孔子、叔孙通，因此国家招致大乱，声誉污辱至今。所以，治理或动乱、荣誉或耻辱的始点，在于所信任的人是谁；既然信任贤良，还要在于坚定不移。《诗经》上说：‘我心并非石头，不可任人扭转。’讲的是信守善义之心要坚定。《易经》上说‘像发汗一般发出庄重的号令’。说的是号令如汗，汗出来了是不能返回的。如今发出好的诏令未过一个时令〔〖按〗三个月〕即收回，是在收回已出的汗；用贤臣未到三十天便斥退，如在搬转石头。《论语》上说：‘看见不善之事如同手触热烫的水。’如今丞相、御史大夫二府启奏过，称那些奸佞谄媚之人不应留在官位，可是历年来都去除不掉。既是发出诏令如同返汗，任用贤人如同转弄石头，而去除奸佞却如同拔山，这样，期待着阴阳能够谐调，不就太难了吗！

　　“所以，一群小人窥见漏洞，便用修饰出来的字句，巧言地加以丑化诋毁，使流言蜚语喧哗于民间。故而《诗经》说：‘孤独地忧心着，愤恨这一群小人。’小人成群，真的实在可恨。昔日孔子与颜渊、子贡互相称誉，不为拉帮结党；夏禹、后稷与皋陶相互引荐，不为扩充自己的势力。为什么？忠心为国，没有邪念啊！今日奸邪之徒与贤臣并处于武士交戟而立的朝廷之内，他们联合同党一块谋算，做着有违良善的坏事；信口开合，多作危言耸听之语，想以此让皇上倾向于他们。皇上若不经意间采用了他们，这便是天地之所以要先行告戒，灾异之事之所以连番而至的原因。自古明圣的君主，未有不施用诛杀之刑而能治国的，所以舜有放逐‘四凶’的刑罚，孔子有城前两观之下的诛杀，然后圣德教化得以施行。今日陛下应以自己的明智，认真深思天地之心，阅“否”“泰”之卦，厉览周成王、唐尧的用人之道作为法则，思虑秦国、鲁国的弃才之痛作为警戒。考察吉兆之福，反思灾异现象之祸，用以揆测当今天下的变化。把那帮奸邪的朋党流放到远地，端掉制造危言耸听的窝巢，关闭一群枉法之徒的方便之门，方能开通正直的众臣之路。要在疑惑中做出决断，在犹豫中做出甄别，使是非曲直明白可知，则所有灾异之象消隐而祥瑞之象呈现。有了太平的基础，才是万世之利！”

　　中书令石显见到这份上书，愈加与许嘉、史高勾结而怨恨刘更生等人。

　　【原文】

　　是岁，夏寒，日青无光。显及许、史皆言堪、猛用事之咎。上内重堪，又患众口之浸润，〔〖胡三省注〗郑氏曰：谮人之言如水之浸润，渐以成之。孔子曰：浸润之谮不行焉，可谓明也已矣。〕无所取信。时长安令杨兴以材能幸，常称誉堪；上欲以为助，乃见问兴：“朝臣龂龂不可光禄勋，何邪？”〔〖胡三省注〗师古曰：龂龂，忿疾之意也。〖按〗龂，音银。〕兴者，倾巧士，谓上疑堪，因顺指曰：“堪非独不可于朝廷，自州里亦不可也。〔〖胡三省注〗《周礼》：五党为州，五家为邻，五邻为里。汉人谓同州乡而居者为州里。〖按〗指：所指，问题。〕臣见众人闻堪与刘更生等谋毁骨肉，以为当诛；故臣前书言堪不可诛伤，为国养恩也。”上曰：“然此何罪而诛？今宜奈何？”兴曰：“臣愚以为可赐爵关内侯，食邑三百户，勿令典事。明主不失师傅之恩，此最策之得者也。”上于是疑之。

　　【译文】

　　这一年，夏季感觉寒冷，太阳青白而无光。中书令石显及许嘉、史高都说是由于周堪、张猛做事不利的罪过。皇上内心器重周堪，又担心不断招来众人口舌，因而无所适从。当时，长安令杨兴以有才学受到皇上喜爱，还常称赞周堪；皇上想让他帮忙，便召见杨兴问道：“朝臣们忿忿不容光禄勋周堪，为什么呢？”杨兴是个极善于机巧变化的人物，以为皇上怀疑周堪，于是顺随着所问回答道：“周堪不仅不容于朝廷，就是乡里之间也不容他。臣见到众人一听说周堪和刘更生等人曾谋陷自己的骨肉至亲，都认为该杀；而臣前面上书说周堪不可以诛杀，是为国蓄养恩惠啊。”皇上说：“然而这是犯了何罪而要诛杀呢？现在该怎么办？”杨兴说：“愚臣认为可以赐封关内侯，享用三百户贡税，不让他管事。明主不失师傅恩义，这是计策中最为合适的了。”皇上于是对周堪有了疑惑。

　　【原文】

　　司隶校尉琅邪诸葛丰〔〖胡三省注〗《姓谱》：葛氏，先本琅邪诸县人，徙阳都；时人本其先之所居，谓之诸葛氏。《风俗通》云：葛婴为陈涉将，有功而诛，孝文录其后，封诸县侯，因并氏焉。〕始以特立刚直著名于朝，数侵犯贵戚，在位多言其短。后坐春夏系治人，〔〖胡三省注〗春、夏，生长之时，故仲春省囹圄，去桎梏，毋肆掠，止狱讼；仲夏挺重囚，益其食。春夏而系治人，为不顺天时。〕徙城门校尉。丰于是上书告堪、猛罪，上不直丰，乃制诏御史：“城门校尉丰，前与光禄勋、光禄大夫猛在朝之时，数称言堪、猛之美。丰前为司隶校尉，不顺四时，修法度，专作苛暴以获虚威；朕不忍下吏，以为城门校尉。〔〖胡三省注〗《百官表》：城门校尉，掌京师十二城门屯兵。〕不内省诸己，而反怨堪、猛以求报举，〔〖胡三省注〗师古曰：言举其事以报怨。〕告按无证之辞，暴扬难验之罪，毁誉恣意，不顾前言，〔〖胡三省注〗师古曰：前言，谓誉堪、猛之美；今乃更言其短，是不顾也。〕不信之大也。朕怜丰之耆老，不忍加刑，其免为庶人！”又曰：“丰言堪、猛贞信不立，朕闵而不治，又惜其材能未有所效，其左迁堪为河东太守，猛槐里令。”〔〖胡三省注〗槐里，周之太丘，秦曰废丘；高帝二年改曰槐里，属右扶风。〕

　　【译文】

　　司隶校尉、琅邪郡的诸葛丰，最初以任性刚直闻名于朝廷，多次冒犯皇亲国戚，大臣们多说他的坏话。后因违犯了春夏两季不拘捕和惩治犯人的禁令，被降职为城门校尉。诸葛丰于此时上书控告周堪、张猛，皇上认为诸葛丰不正直，便制定诏书给御史道：“城门校尉诸葛丰，之前与光禄勋周堪、光禄大夫张猛在朝之时，多次称赞周堪、张猛之美。诸葛丰以前任职司隶校尉，不顺应四时节令，擅改法度，专行苟刻暴力之事以获取威严虚名；朕不忍将其送交法办，让他去担任城门校尉。他不向内反省自己，而反倒怨恨周堪、张猛以求报复，控告中采用没有证据的言辞，揭露时抛出难以验证的罪状，恣意损毁他人名誉，不顾忌自己以前的言语，这是严重的不诚信行为。朕怜悯诸葛丰是位老者，不忍施加刑罚，今将其罢免为平民。”又讲道：“诸葛丰说周堪、张猛没有贞节和信用，朕出于怜悯之心就不去处治他们了，但可惜他们的才能没有什么建树，现在降职周堪任河东太守，张猛任槐里令。”

　　【原文】

　　臣光曰：诸葛丰之于堪、猛，前誉而后毁，其志非为朝廷进善而去奸也，欲比周求进而已矣。斯亦郑朋、杨兴之流，乌在其为刚直哉。人君者，察美恶，辨是非，赏以劝善，罚以惩奸，所以为治也。使丰言得实，则丰不当绌；若其诬罔，则堪、猛何辜焉！今两责而俱弃之，则美恶、是非果何在哉！

　　【译文】

　　臣司马光认为：“诸葛丰对于周堪、张猛，先是赞誉而后又诋毁，其用意不是为朝廷举贤除奸，不过是想结交朋党以求重用而已。这种人也属于郑朋、杨兴之流，不在于他自己的什么刚直。作为人的君主，应审察美恶，明辨是非，以赏劝善，以罚惩奸，国家因此才得以治理。如果诸葛丰之言属实，则诸葛丰就不应当被罢免；若他属于诬陷，则周堪、张猛又有何辜呢？如今两方被问责，俱都抛弃，那么美恶、是非的区别真的还在吗？”

　　【原文】

　　贾捐之与杨兴善。捐之数短石显，〔〖胡三省注〗师古曰：谈说其长短。余谓此言数陈其短耳。数，所角翻。〕以故不得官，稀复进见。〔〖按〗稀，于此同希。〕兴新以材能得幸。捐之谓兴曰：“京兆尹缺，〔〖胡三省注〗按《百官表》：初元四年，京兆尹成。永光四年，光禄大夫琅邪张谭为京兆尹；四年，不胜任，免。盖是时成已去而谭未除，是以缺官也。〕使我得见言君兰，〔〖胡三省注〗张晏曰：杨兴，君兰（蘭）。《考异》曰：荀纪作“君简（簡）”，今从《汉书》。〕京兆尹可立得。”兴曰：“君房下笔，言语妙天下；〔〖胡三省注〗贾捐之，字君房。师古曰：于天下最为精妙耳。〕使君房为尚书令，胜五鹿充宗远甚。”〔〖胡三省注〗《续汉志》曰：尚书令，承秦所置；武帝用宦者更为中书谒者令。是时石显为中书令，五鹿充宗为尚书令，疑两官并置也。《百官表》：成帝建始元年，尚书令五鹿充宗为少府；五年，贬为玄菟太守。逆而数之，则知充宗是年犹为尚书令也。《姓谱》：赵大夫食采于五鹿，以邑为氏。〖按〗五鹿充宗：西汉名儒，氏五鹿，名充宗，卫之五鹿人，以地为氏。〕捐之曰：“令我得代充宗，君兰为京兆。京兆，郡国首；尚书，百官本。天下真大治，士则不隔矣！”捐之复短石显，兴曰：“显方贵，上信用之；今欲进，第从我计，〔〖胡三省注〗师古曰：第，但也。〕且与合意，即得入矣！”捐之即与兴共为荐显奏，称誉其美，以为宜赐爵关内侯，引其兄弟以为诸曹。又共为荐兴奏，以为可试守京兆尹。石显闻知，白之上，乃下兴、捐之狱，令显治之。奏：“兴、捐之怀诈伪，更相荐誉，欲得大位，罔上不道。”捐之竟坐弃市，兴髡钳为城旦。

　　臣光曰：君子以正攻邪，犹惧不克，况捐之以邪攻邪，其能免乎？

　　徙清河王竟为中山王。〔〖按〗汉元帝刘奭之弟。〕

　　匈奴呼韩邪单于民众益盛，塞下禽兽尽。单于足以自卫，不畏郅支，其大臣多劝单于北归者。〔〖胡三省注〗师古曰：塞下无禽兽，则射猎无所得；又不畏郅支，故欲北归旧处。〕久之，单于竟北归庭，民众稍稍归之，其国遂定。

　　【译文】

　　贾捐之与杨兴关系亲善。贾捐之多次揭石显的短处，为这事他得不到封加官职，希望再次进见皇上。杨兴由于有才干近来得到皇帝赏识。贾捐之对杨兴说：“京兆尹职位正在空缺，若能让我见到皇上并为你进言，你立即可以得到京兆尹位置。”杨兴说：“你下笔，言语称妙于天下；你若能当尚书令，将远远胜过五鹿充宗这个人。”贾捐之说：“使我得以取代五鹿充宗的尚书令位置，你为京兆尹。京兆，郡国之首；尚书，百官之本。天下会实现大的治理，士子的前途便没有阻隔了！”贾捐之又揭石显的短处，杨兴说：“石显正处于显贵地位，皇上信用他；如今你想上去，但依我的计策，只要符合皇上的心意，便能进入官职了！”贾捐之便与杨兴共同拟写了推荐石显的奏章，赞誉他的美德，建议应赏赐他关内侯爵位，可引用他的兄弟任职诸曹之官。又共同拟写了举荐杨兴的奏章，建议可试任京兆尹一职。石显闻知此事，告发给皇上，于是贾捐之与杨兴被下狱，责令石显处治他们。石显奏道：“贾捐之与杨兴心怀奸诈虚伪，互相举荐赞誉，欲谋得大的官位，欺君罔上，大逆不道。”贾捐之最终被处以“弃市”极刑，杨兴被剃发钳颈做了“城旦”囚徒。

　　〔〖按〗髡钳：古代刑罚，即剃去头发，铁圈束颈。城旦：男罪犯刑罚，意为“治城”，即筑城、守城。另有针对女罪犯的刑罚，称为“舂”，意为“治米”，即舂米。城旦、舂，均为秦汉时期徒刑，秦四年，汉五年。〕

　　臣司马光认为：作为正人君子以正道来斗邪恶，尚且恐怕不能取胜，何况贾捐之以歪门邪道来斗邪恶，他怎能幸免呢？

　　迁徙清河王刘竟为中山王。

　　匈奴呼韩邪单于的民众益加繁盛，塞下禽兽被猎尽。单于已有足够的自卫力量，不再惧怕郅支国，其大臣们多劝单于北归。久后，单于真就北归到原来旧址，民众也逐渐归附过来，其国也自此得以安定。

　　【原文】

　　汉孝元皇帝　永光二年（己卯　公元前42年）

　　春，二月，赦天下。

　　丁酉，御史大夫韦玄成为丞相，右扶风郑弘为御史大夫。

　　三月，壬戌朔，日有食之。

　　夏，六月，赦天下。

　　【译文】

　　汉元帝永光二年（己卯　公元前42年）

　　春季，二月，大赦天下。

　　丁酉（二月五日），御史大夫韦玄成封为宰相，右扶风郑弘封为御史大夫。

　　三月，壬戌朔（三月一日），出现日食。

　　夏季，六月，大赦天下。

　　【原文】

　　上问给事中匡衡以地震日食之变，〔〖胡三省注〗匡衡时以博士给事中。《风俗通》云：匡，鲁邑，句须为之宰；其后氏焉。〕衡上疏曰：

　　“陛下躬圣德，开太平之路，闵愚吏民触法抵禁，比年大赦，使百姓得改行自新，天下幸甚！臣窃见大赦之后，奸邪不为衰止。今日大赦，明日犯法，相随入狱，此殆导之未得其务也。今天下俗，贪财贱义，好声色，上侈靡；亲戚之恩薄，婚姻之党隆；苟合徼幸，以身设利。不改其原，〔〖胡三省注〗師古曰：设，施也。原，本也。〕虽岁赦之，刑犹难使错而不用也。〔〖胡三省注〗师古曰：岁赦，谓每岁一赦也。错，置也。〕臣愚以为，宜壹旷然大变其俗！夫朝廷者，天下之桢幹也。〔〖胡三省注〗桢干，版筑之具：题曰桢，旁曰干，以筑垣墙，喻治天下也。桢，音贞。〕朝有变色之言，则下有争斗之患；上有自专之士，则下有不让之人；上有克胜之佐，〔〖按〗佐，左计也。《古今韵会举要》卷十五：“策画不适事宜曰左计。”〕则下有伤害之心；上有好利之臣，则下有盗窃之民。此其本也。〔〖胡三省注〗师古曰：言下之所行，皆取化于上也。〕治天下者，审所上而已。〔〖胡三省注〗师古曰：上，谓崇尚也。〖按〗师古之解或有误。依此处文义，“所上”，应指所处朝廷之上。言治天下者，应自上行者审也。〕教化之流，非家至而人说之也。〔〖胡三省注〗师古曰：非家家皆到，人人劝说也。〕贤者在位，能者布职，朝廷崇礼，百僚敬让，道德之行由内及外，自近者始，然后民知所法，迁善日进而不自知也。

　　“《诗》曰：‘商邑翼翼，四方之极。’〔〖胡三省注〗师古曰：《商颂·殷武》之诗也。商邑，京师也。极，中也。言商邑之礼俗，翼翼然可则傚，是乃四方之中正也。〕今长安，天子之都，亲承圣化，然其习俗无以异于远方。郡国来者无所法则，或见侈靡而放效之。〔〖胡三省注〗师古曰：放，依也，音甫往翻。〕此教化之原本，风俗之枢机，宜先正者也。臣闻：天人之际，精祲有以相荡，〔〖胡三省注〗李奇曰：祲，气也；言天人精气相动也。师古曰：祲，谓阴阳之气相浸渐以成灾祥者也。〕善恶有以相推；事作乎下者，象动乎上；阴变则静者动，阳蔽则明者晻；〔〖胡三省注〗邓展曰：静者动，谓地震也；明者晻，谓日食也。师古曰：晻，与暗同。〕水旱之灾，随类而至。陛下祗畏天戒，哀闵元元，宜省靡丽，考制度，近忠正，远巧佞，以崇至仁，匡失俗。道德弘于京师，淑问扬乎疆外，〔〖胡三省注〗师古曰：淑，善也。问，名也。〕然后大化可成，礼让可兴也。”

　　上说其言，〔〖胡三省注〗说，读曰悦〕迁衡为光禄大夫。

　　【译文】

　　皇上就地震日食等天地变故咨询给事中匡衡，衡匡上书说：

　　“陛下亲身奉行圣人之德，开辟太平之路，怜悯那些触犯法律和禁令的愚昧官民，连年都有大赦，使百姓得以改过自新，实为天下大幸！然而，臣发现大赦之后，作奸犯科的人并未因此减少。今天遇大赦出狱，明日却又犯法，随后重新入狱，这大概是教导上不得其法。当前天下风气低俗，贪钱财、轻道义，喜爱声色犬马，以豪华奢侈为时尚；亲戚的恩义淡薄，有联姻关系的朋党却很火热；只为迎合那点侥幸，不惜以身试法去谋利。如果不从根源上加以改变，虽年年大赦，刑法仍然难以搁置不用。愚臣以为，应该豁然痛改这种世俗风气！作为朝廷，如筑城的模具一般规范着天下。朝廷上有怒色激辩，则下面就有争斗之祸；朝廷上有擅自专权之官，则下面就有独霸之人；朝廷上有好胜的不正当谋算，则下面就有伤害他人之心；朝廷上有贪图名利之臣，则下面就有盗窃之民。根源即在如此。能治理天下的人，无非明察所在朝廷之上的大臣们而已。礼义教化的推行，用不着挨门挨户的逢人劝说。只要贤德之人在位，能干的人尽职，朝廷崇尚礼义，文武百官相互敬让，道德的奉行由内而及外，从身边的人事做起，然后民众才知道效法，这样，社会风俗便会在潜移默化中改善了。

　　“《诗经》上说：‘巍然商都，四方景仰的中心。’今天的长安，天子所在的都城，是直接传承圣上教化的地方，然而它的社会习俗没有因此就与偏远之地有什么不同。各郡国来的人见不到可供效法的规范，或许见到奢侈荒淫的东西便去仿效它。这个施行教化的本源，风俗传播的枢纽，是最该首先予以整顿的。臣听说：天人关系之中，精气与邪气可以相互冲荡，善与恶可以相互借以推动；事作于下，则迹象感应于上；阴的方面异变则会引起静止的事物动荡，阳的方面被掩蔽则会使明亮的东西失去光彩。因而，旱涝之灾也就会跟随着这类现象发生了。既然陛下敬畏上天的示警，悲悯黎民百姓，就应该去除奢靡，考查制度，接近忠正之人，远离奸巧之辈，以崇尚纯正的仁义，匡扶败坏掉的风俗。道德在京师得到弘扬，美誉传扬于四方，然后才可能实现教化天下，礼让之风可以复兴。

　　汉元帝欣赏衡匡的话，升迁他为光禄大夫。

　　【原文】

　　荀悦论曰：夫赦者，权时之宜，非常典也。汉兴，承秦兵革之后，大愚之世，比屋可刑，〔〖按〗比，音辟，同毗，毗连。〕故设三章之法、大赦之令，〔〖胡三省注〗约法三章，事见九卷高帝元年。赦，自古有之，至于大赦，则始于秦。高祖既并天下，即皇帝位，大赦天下，后世因之为永制。〕荡涤秽流，与民更始，时势然也。后世承业，袭而不革，失时宜矣。若惠、文之世，无所赦之。若孝景之时，七国皆乱，异心并起，奸诈非一；及武帝末年，赋役繁兴，群盗并起，加以太子之事、巫蛊之祸，天下纷然，百姓无聊，人不自安。及光武之际，拨乱之后，如此之比，〔〖按〗比，音鄙，较也。与“比屋”之“比”不同。〕宜为赦矣。

　　【译文】

　　荀悦评论说：至于大赦，不过权衡于一时的需要，并不是常规的法典。汉朝的兴建，是继秦代战乱之后，当时是个普遍矇昧的社会，挨家挨户都可问罪，故而制定“约法三章”、大赦的告令，荡涤污泥浊水，给民众一个重新做人的机会，这是当时的形势使然。后世继承祖业，只沿袭旧制而不加以变革，就有失时宜了。比如汉惠帝、汉文帝之时，就无须什么大赦。比如孝景帝之时，七国都出现动乱，不轨之心纷起，奸诈之徒不只一类；及至武帝末年，税赋杂役繁多，群盗接连而起，加上太子刘据事件、巫言蛊惑之祸，天下纷乱，百姓无以聊生，人人不能自保。直到光武帝（刘秀）年代平乱之后，像这种时候，就有必要施行大赦了。

　　【原文】

　　秋，七月，陇西羌彡姐旁种反，〔〖胡三省注〗师古曰：“彡”，音所廉翻，又音先廉翻。“姐”，音紫。今西羌尚有此姓，而“彡”，音先冉翻。〕诏召丞相韦玄成等入议。是时，岁比不登，朝廷方以为忧，而遭羌变。玄成等漠然，莫有对者。〔〖胡三省注〗师古曰：漠，无声也，音莫。〕

　　右将军冯奉世曰：“羌虏近在竟内背畔，〔〖胡三省注〗竟，古境字通用。〕不以时诛，无以威制远蛮。臣愿帅师讨之！”〔〖胡三省注〗帅，读曰率。〕上问用兵之数，对曰：“臣闻善用兵者，役不再兴，粮不三载，故师不久暴而天诛亟决。〔〖胡三省注〗师古曰：暴，露也。亟，急也。载，子亥翻。。〕往者数不料敌，〔〖胡三省注〗師古曰：料，量也，音聊。〕而师至于折伤。再三发调，则旷日烦费，威武亏矣。今反虏无虑三万人，〔〖胡三省注〗师古曰：无虑，举凡之言，无小思虑而大计也。〕法当倍，用六万人。然羌戎，弓矛之兵耳，器不犀利，〔〖胡三省注〗如淳曰：今俗以刀兵利为犀。晋灼曰：犀，坚也。师古曰：晋说是。〕可用四万人。一月足以决。”丞相、御史、两将军〔〖胡三省注〗两将军，车骑将军王接、左将军许嘉也。〕皆以为：“民方收敛时未可多发，发万人屯守之，且足。”〔〖胡三省注〗且足，犹言且可也。敛，力赡翻。〕奉世曰：“不可。天下被饥馑，〔〖胡三省注〗被，皮义翻。〖按〗音披。〕士马羸耗，守战之备久废不简，〔〖胡三省注〗师古曰：简，谓选拣。〕夷狄皆有轻边吏之心，而羌首难。〔〖胡三省注〗师古曰：言创首为寇难也。难，乃旦翻。〕今以万人分屯数处，虏见兵少，必不畏惧；战则挫兵病师，守则百姓不救。如此，怯弱之形见。羌人乘利，诸种并和，〔〖胡三省注〗种，章勇翻。师古曰：和，应也，音胡卧翻。〖按〗古音豁，今音贺。〕相扇而起，臣恐中国之役不得止于四万，非财币所能解也。故少发师而旷日，〔〖胡三省注〗师古曰：旷，空也；空费其日而无功也。〕与一举而疾决，利害相万也。”〔〖胡三省注〗师古曰：相比为万倍也。〕固争之，不能得。〔〖胡三省注〗言奉世不能得请也。〕有诏，益二千人。于是遣奉世将万二千人骑，以将屯为名，〔〖胡三省注〗师古曰：且云领兵屯田，不言讨贼。将，即亮翻。〕典属国任立、护军都尉韩昌为偏裨，到陇西，分屯三处。〔〖胡三省注〗任立为右军，屯白石。韩昌为前军，屯临洮。奉世为中军，屯首阳西极上。任，音壬。〕昌先遣两校尉与羌战，羌虏盛多，皆为所破，杀两校尉。

　　奉世具上地形部众多少之计，愿益三万六千人，乃足以决事。书奏，天子大为发兵六万馀人。

　　八月，拜太常弋阳侯任千秋为奋武将军以助之。〔〖胡三省注〗昭帝时，宫以捕上官桀功，封弋阳侯，千秋其子也。弋阳侯国，属汝南郡。应劭曰：弋山在西北。〕

　　冬，十月，兵毕至陇西。十一月，并进，羌虏大破，斩首数千级，馀皆走出塞。兵未决间，汉复发募士万人，拜定襄太守韩安国为建威将军，〔〖胡三省注〗师古曰：自别有此韩安国，非武帝时人也。〕未进，闻羌破而还。

　　诏罢吏士，〔〖胡三省注〗吏，军吏；士，卒也。〕颇留屯田，备要害处。〔〖胡三省注〗师古曰：要害者，在我为要，于敌为害也。〕

　　【译文】

　　秋季，七月，陇西郡（甘肃）羌人彡姐的旁支反叛，皇上下诏召丞相韦玄成等人入朝议事。当时，连年粮食欠收，朝廷正为此事忧虑，却又遭羌人叛变。丞相韦玄成等人漠然不语，没有回应之人。

　　右将军冯奉世说道：“羌族贼兵在境内反叛，若不及时剿杀，无法威慑远地蛮夷之族。臣愿帅领大军讨伐它！”皇上询问需用多少兵马？答道：“臣得知善用兵的人，不会为同一战事两次起兵，不会三次载运粮草，为此军队不应长久暴露野外而须速战速决。过去征剿时多没有搞清敌情，以至于军队受到挫伤。而接二连三地调动士兵，则费时耗物，军队的锐气就亏损了。今叛乱的虏寇不过三万人，按兵法当出兵一倍，用六万人。然而羌人队伍以弓矛为兵器，兵器也不锋利，我们可用四万人，一个月足以解决战斗。”丞相、御史及车骑将军、左将军都认为：“百姓正在秋收季节，兵不可多发，以一万人驻扎防守就够了。”冯奉世说：“不可！天下正遭受饥饿，兵马因瘦弱而体力耗损，加上战备物质长久废置而未检，边外夷狄之人都有轻视边境官吏之心，而羌人是首先发难者。今若以一万人分兵驻守于多处，敌寇见兵少，必然不会畏惧；战则损兵折军，守则不足以救助百姓。这样，就显现出怯弱势态出来。羌人乘着有利时机，各族群一齐呼应，相互煽动起兵，那时，臣恐怕咱们中原国需征收的兵役就不止于四万了，也不是金钱所能解决的了。因此，少发兵马而旷日持久，与一举剿灭而速战速决，其间利害则相差万倍。”冯奉世坚持力争，不能得到更多兵马。下诏，在一万人基础上再增加二千人。于是派遣冯奉世率领一万二千兵马，以领兵屯田名义发兵。典属国任立、护军都尉韩昌为偏将副手，到陇西郡，分别屯兵于三处。韩昌先派遣两校尉与羌兵作战，因羌兵盛多，而都被打败了，两校尉被杀。

　　冯奉世向朝廷呈上根据地形态势应部署的人数计划，希望增加三万六千人，才足够解决战事。上奏之后，皇上一气发兵六万余人。

　　八月，拜立太常弋阳侯任千秋为奋武将军，前去助战。

　　冬季，十月，兵马全部集结于陇西。十一月，齐头并进，大破羌兵，斩首数千级，剩下的全部逃出塞外。交兵未决胜败期间，汉朝廷又派发所招募的勇士万人，拜授定襄太守韩安国为建威将军，未待进军，闻听羌兵已破而返回。

　　诏令休战的官兵，多留一些人从事驻守垦田，防备于要害之处。

　　〔〖胡三省注〗译注/璞如子　




			
